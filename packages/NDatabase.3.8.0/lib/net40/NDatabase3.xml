<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NDatabase3</name>
    </assembly>
    <members>
        <member name="T:NDatabase.Api.CascadeDeleteAttribute">
            <summary>
            Use when you want to do a cascade delete on field object. 
            </summary>
            <remarks>
            In such case, mark the attribute with <code>[CascadeDelete]</code>
            </remarks>
        </member>
        <member name="T:NDatabase.Api.IOdbForTrigger">
            <summary>
            Database engine interface (simplified for triggers purpose). 
            </summary>
            <remarks>
            The interface provides all methods from IOdb which are allowed to access in triggers.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.Store``1(``0)">
            <summary>
            Stores the specified plain object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>Object ID of stored plain object.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.GetValues(NDatabase.Api.Query.IValuesQuery)">
            <summary>
            Gets the values that matches the values query.
            </summary>
            <param name="query">The values query.</param>
            <returns>The list of values that matches the values query.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.Delete``1(``0)">
            <summary>
            Deletes the specified plain object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>Object ID of deleted plain object.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.DeleteObjectWithId(NDatabase.Api.OID)">
            <summary>
            Deletes the object with Object ID.
            </summary>
            <param name="oid">The oid of the object to be deleted.</param>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.GetObjectId``1(``0)">
            <summary>
            Gets the object id of an database-aware object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>The database internal Object ID.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.GetObjectFromId(NDatabase.Api.OID)">
            <summary>
            Gets the object from Object ID.
            </summary>
            <param name="id">The Object ID.</param>
            <returns>The object with the specified Object ID.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.Ext">
            <summary>
            Get the extension of database interface to get the access to advanced functions
            </summary>
            <returns>Extended interface to database.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.IsClosed">
            <summary>
            Determines whether the database is closed.
            </summary>
            <returns>
              <c>true</c> if the database is closed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.QueryAndExecute``1">
            <summary>
            Queries the database for instances of specified type and execute the query.
            </summary>
            <remarks>
            Shortcut for <code>Query&lt;T&gt;().Execute&lt;T&gt;()</code>
            </remarks>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>List of stored objects that matches the query.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.Query``1">
            <summary>
            Factory method to create a new instance of the query.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>New instance of query for the specified object type.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.ValuesQuery``1">
            <summary>
            Factory method to create a new instance of the values query.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>New instance of values query for the specified object type.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.ValuesQuery``1(NDatabase.Api.OID)">
            <summary>
            Factory method to create a new instance of the values query for specified oid.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="oid">The oid of the stored plain object.</param>
            <returns>New instance of values query for the specified object with a given oid.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdbForTrigger.AsQueryable``1">
            <summary>
            As the queryable.
            </summary>
            <remarks>
            Interface for LINQ to NDatabase
            </remarks>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>Queryable collection</returns>
        </member>
        <member name="T:NDatabase.Api.OIDAttribute">
            <summary>
            Use when you want to enrich your class with OID.
            You can apply it on fields of type: long or OID.
            </summary>
            <remarks>
            In such case, mark the attribute with <code>[OID]</code>
            </remarks>
        </member>
        <member name="T:NDatabase.Api.Triggers.SelectTrigger">
            <summary>
            Abstract class - derive from it if you want to create select trigger
            </summary>
        </member>
        <member name="T:NDatabase.Api.Triggers.Trigger">
            <summary>
              A simple base class for all triggers.
            </summary>
        </member>
        <member name="P:NDatabase.Api.Triggers.Trigger.Odb">
            <summary>
            Access to NDatabase interface connected with created trigger
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.SelectTrigger.AfterSelect(System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen after select
            </summary>
            <param name="object">Selected object</param>
            <param name="oid">OID of selected object</param>
        </member>
        <member name="F:NDatabase.Btree.AbstractBTreeIterator`1.CurrentNode">
            <summary>
              The current node where the iterator is
            </summary>
        </member>
        <member name="F:NDatabase.Btree.AbstractBTreeIterator`1.NbReturnedElements">
            <summary>
              The number of returned elements ; it may be different from the number of keys in the case f multileValues btree where a key can contain more than one value
            </summary>
        </member>
        <member name="F:NDatabase.Btree.AbstractBTreeIterator`1._currentKeyIndex">
            <summary>
              The current key in the current node where the iterator is
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.IQueryManager.GetQueryExecutor(NDatabase.Api.Query.IQuery,NDatabase.Core.IStorageEngine)">
            <summary>
              Returns a multi class query executor (polymorphic = true)
            </summary>
        </member>
        <member name="M:NDatabase.Exceptions.ExceptionsHelper.ReplaceToken(System.String,System.String,System.String,System.Int32)">
            <summary>
              Replace a string within a string
            </summary>
            <param name="inSourceString"> The String to modify </param>
            <param name="inTokenToReplace"> The Token to replace </param>
            <param name="inNewToken"> The new Token </param>
            <param name="inNbTimes"> The number of time, the replace operation must be done. -1 means replace all </param>
            <returns> String The new String </returns>
        </member>
        <member name="M:NDatabase.Services.IMetaModelCompabilityChecker.Check(System.Collections.Generic.IDictionary{System.Type,NDatabase.Meta.ClassInfo},NDatabase.Services.IMetaModelService)">
            <summary>
                Receive the current class info (loaded from current classes present on runtime and check against the persisted meta model
            </summary>
        </member>
        <member name="M:NDatabase.Meta.MetaModelCompabilityChecker.Check(System.Collections.Generic.IDictionary{System.Type,NDatabase.Meta.ClassInfo},NDatabase.Services.IMetaModelService)">
            <summary>
                Receive the current class info (loaded from current classes present on runtime and check against the persisted meta model
            </summary>
        </member>
        <member name="T:NDatabase.Exceptions.BTreeError">
            <summary>
              ODB BTree Errors All @ in error description will be replaced by parameters
            </summary>
        </member>
        <member name="M:NDatabase.Exceptions.BTreeError.ToString">
            <summary>
              replace the @1,@2,...
            </summary>
            <remarks>
              replace the @1,@2,... by their real values.
            </remarks>
        </member>
        <member name="T:NDatabase.Btree.BTreeIteratorMultipleValuesPerKey`1">
            <summary>
              An iterator to iterate over NDatabase BTree that accept more than one value per key.
            </summary>
            <remarks>
              An iterator to iterate over NDatabase BTree that accept more than one value per key. This is used for non unique index and collection that return ordered by results
            </remarks>
        </member>
        <member name="F:NDatabase.Btree.BTreeIteratorMultipleValuesPerKey`1._currenListIndex">
            <summary>
              The index in the list of the current value, Here values of a key are lists!
            </summary>
        </member>
        <member name="F:NDatabase.Btree.BTreeIteratorMultipleValuesPerKey`1._currentValue">
            <summary>
              The current value(List) of the current key being read.
            </summary>
            <remarks>
              The current value(List) of the current key being read.
            </remarks>
        </member>
        <member name="M:NDatabase.Btree.BTreeIteratorMultipleValuesPerKey`1.#ctor(NDatabase.Btree.IBTree,NDatabase.Api.OrderByConstants)">
            <param name="tree"> </param>
            <param name="orderByType"> </param>
        </member>
        <member name="T:NDatabase.Btree.BTreeIteratorSingleValuePerKey`1">
            <summary>
              An iterator to iterate over NDatabase BTree.
            </summary>
            <remarks>
              An iterator to iterate over NDatabase BTree.
            </remarks>
        </member>
        <member name="T:NDatabase.Btree.InMemoryPersister">
            <summary>
              In memory persister
            </summary>
        </member>
        <member name="T:NDatabase.Btree.IBTreePersister">
            <summary>
              Interface used to persist and load btree and btree node from a persistent layer
            </summary>
        </member>
        <member name="T:NDatabase.Exceptions.BTreeException">
            <summary>
            Exception raised when error in BTrees will appear
            </summary>
        </member>
        <member name="T:NDatabase.Exceptions.OdbRuntimeException">
            <summary>
              Generic ODB Runtime exception : Used to report all problems.
            </summary>
        </member>
        <member name="T:NDatabase.Exceptions.BTreeNodeValidationException">
            <summary>
            Exception raised when error in BTrees will appear (validation error)
            </summary>
        </member>
        <member name="T:NDatabase.Exceptions.DuplicatedKeyException">
            <summary>
            Exception raised when error in BTrees will appear (Duplicated key)
            </summary>
        </member>
        <member name="T:NDatabase.Btree.IBTreeNode">
            <summary>
              The interface for btree node.
            </summary>
        </member>
        <member name="M:NDatabase.Btree.IBTreeNode.GetPositionOfKey(System.IComparable)">
            <summary>
              Returns the position of the key.
            </summary>
            <remarks>
              Returns the position of the key. If the key does not exist in node, returns the position where this key should be,multiplied by -1 
                                                                                                                                                 
             <pre>or example for node of degree 3 : [1 89 452 789 - ],    
               calling getPositionOfKey(89) returns 2 (starts with 1)    
               calling getPositionOfKey(99) returns -2 (starts with 1),because the position should be done, but it does not exist so multiply by -1
               his is used to know the child we should descend to!in this case the getChild(2).</pre>
            
            </remarks>
            <param name="key"> </param>
            <returns> The position of the key,as a negative number if key does not exist, warning, the position starts with 1and not 0! </returns>
        </member>
        <member name="T:NDatabase.Btree.IBTreeNodeMultipleValuesPerKey">
            <summary>
              The interface for btree nodes that accept One Value Per Key
            </summary>
        </member>
        <member name="T:NDatabase.Btree.IBTreeNodeOneValuePerKey">
            <summary>
              The interface for btree nodes that accept multiple values for each key
            </summary>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTree.Delete(System.IComparable,System.Object)">
            <summary>
              TODO Manage collision
            </summary>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTree.Split(NDatabase.Btree.IBTreeNode,NDatabase.Btree.IBTreeNode,System.Int32)">
            <summary>
              <pre>1 take median element
                2 insert the median in the parent  (shifting necessary elements)
                3 create a new node with right part elements (moving keys and values and children)
                4 set this new node as a child of parent</pre>
            </summary>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTree.InternalDelete(NDatabase.Btree.IBTreeNode,NDatabase.Btree.IKeyAndValue)">
            <summary>
              Returns the value of the deleted key
            </summary>
            <param name="node"> </param>
            <param name="keyAndValue"> </param>
            <returns> </returns>
            <exception cref="T:System.Exception">System.Exception</exception>
        </member>
        <member name="F:NDatabase.Btree.AbstractBTreeNode.Btree">
            <summary>
              The BTree owner of this node
            </summary>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTreeNode.ExtractRightPart">
            <summary>
              Creates a new node with the right part of this node.
            </summary>
            <remarks>
              Creates a new node with the right part of this node. This should only be called on a full node
            </remarks>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTreeNode.GetPositionOfKey(System.IComparable)">
            <summary>
              Returns the position of the key.
            </summary>
            <remarks>
              Returns the position of the key. If the key does not exist in node, returns the position where this key should be,multiplied by -1 <pre>for example for node of degree 3 : [1 89 452 789 - ],
                                                                                                                                                   calling getPositionOfKey(89) returns 2 (starts with 1)
                                                                                                                                                   calling getPositionOfKey(99) returns -2 (starts with 1),because the position should be done, but it does not exist so multiply by -1
                                                                                                                                                   this is used to know the child we should descend to!in this case the getChild(2).</pre>
            </remarks>
            <param name="key"> </param>
            <returns> The position of the key,as a negative number if key does not exist, warning, the position starts with 1and not 0! </returns>
        </member>
        <member name="M:NDatabase.Btree.AbstractBTreeNode.MergeWith(NDatabase.Btree.IBTreeNode)">
            <summary>
              Can only merge node without intersection =&gt; the greater key of this must be smaller than the smallest key of the node
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.IFileSystemReader.ReadNumberOfClasses">
            <summary>
              Reads the number of classes in database file
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.IFileSystemReader.ReadFirstClassOid">
            <summary>
              Reads the first class OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.IFileSystemReader.GetAllIds(System.Byte)">
            <summary>
              Returns information about all OIDs of the database
            </summary>
            <param name="idType"> </param>
            <returns> @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.IFileSystemReader.GetObjectPositionFromItsOid(NDatabase.Api.OID,System.Boolean,System.Boolean)">
            <summary>
              Gets the real object position from its OID
            </summary>
            <param name="oid"> The oid of the object to get the position </param>
            <param name="useCache"> </param>
            <param name="throwException"> To indicate if an exception must be thrown if object is not found </param>
            <returns> The object position, if object has been marked as deleted then return StorageEngineConstant.DELETED_OBJECT_POSITION @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.IFileSystemReader.ReadClassInfoHeader(NDatabase.Api.OID)">
            <summary>
              Read the class info header with the specific oid
            </summary>
            <returns> The read class info object @ </returns>
        </member>
        <member name="F:NDatabase.Core.Engine.FileSystemReader._fsi">
            <summary>
                The fsi is the object that knows how to write and read native types
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.FileSystemReader._blockPositions">
            <summary>
              To hold block number.
            </summary>
            <remarks>
              To hold block number. ODB compute the block number from the oid (as one block has 1000 oids), then it has to search the position of the block number! This cache is used to keep track of the positions of the block positions The key is the block number(Long) and the value the position (Long)
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadNumberOfClasses">
            <summary>
                Reads the number of classes in database file
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadFirstClassOid">
            <summary>
                Reads the first class OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadDatabaseVersion">
            <summary>
                Read the version of the database file
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadLastOdbCloseStatus">
            <summary>
                Reads the status of the last odb close
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadDatabaseCharacterEncoding">
            <summary>
                Reads the database character encoding
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.GetAllIds(System.Byte)">
            <summary>
              Returns information about all OIDs of the database
            </summary>
            <param name="idType"> </param>
            <returns> @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.GetObjectPositionFromItsOid(NDatabase.Api.OID,System.Boolean,System.Boolean)">
            <summary>
              Gets the real object position from its OID
            </summary>
            <param name="oid"> The oid of the object to get the position </param>
            <param name="useCache"> </param>
            <param name="throwException"> To indicate if an exception must be thrown if object is not found </param>
            <returns> The object position, if object has been marked as deleted then return StorageEngineConstant.DELETED_OBJECT_POSITION @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.GetIdBlockPositionFromNumber(System.Int64)">
            <param name="blockNumberToFind"> </param>
            <returns> The block position @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemReader.ReadClassInfoHeader(NDatabase.Api.OID)">
            <summary>
              Read the class info header with the specific oid
            </summary>
            <returns> The read class info object @ </returns>
        </member>
        <member name="M:NDatabase.Meta.IMetaModel.GetClassInfoFromId(NDatabase.Api.OID)">
            <summary>
              Gets the class info from the OID.
            </summary>
            <remarks>
              Gets the class info from the OID.
            </remarks>
            <param name="id"> </param>
            <returns> the class info with the OID </returns>
        </member>
        <member name="M:NDatabase.Meta.IMetaModel.GetLastClassInfo">
            <returns> The Last class info </returns>
        </member>
        <member name="M:NDatabase.Meta.IMetaModel.GetClassInfo(System.Int32)">
            <param name="index"> The index of the class info to get </param>
            <returns> The class info at the specified index </returns>
        </member>
        <member name="M:NDatabase.Meta.IMetaModel.AddChangedClass(NDatabase.Meta.ClassInfo)">
            <summary>
              Saves the fact that something has changed in the class (number of objects or last object oid)
            </summary>
        </member>
        <member name="M:NDatabase.Meta.IMetaModel.GetPersistentSubclassesOf(System.Type)">
            <summary>
              Gets all the persistent classes that are subclasses or equal to the parameter class
            </summary>
            <returns> The list of class info of persistent classes that are subclasses or equal to the class </returns>
        </member>
        <member name="T:NDatabase.IO.IDbIdentification">
            <summary>
              An interface to get info about database parameters
            </summary>
        </member>
        <member name="T:NDatabase.IO.IOdbStream">
            <summary>
              The basic IO interface for basic IO operation like reading and writing bytes
            </summary>
        </member>
        <member name="M:NDatabase.IO.IOdbStream.SetPosition(System.Int64)">
            <summary>
             Sets the current position of this stream to the given value
            </summary>
            <param name="position">offset</param>
        </member>
        <member name="P:NDatabase.IO.IOdbStream.Length">
            <summary>
            Gets the length in bytes of the stream
            </summary>
        </member>
        <member name="M:NDatabase.IO.OdbMemoryStream.SetPosition(System.Int64)">
            <summary>
             Sets the current position of this stream to the given value
            </summary>
            <param name="position">offset</param>
        </member>
        <member name="P:NDatabase.IO.OdbMemoryStream.Length">
            <summary>
            Gets the length in bytes of the stream
            </summary>
        </member>
        <member name="T:NDatabase.Api.Query.IConstraint">
             <summary>
             constraint to limit the objects returned upon
             query execution.
             
             
             Constraints are constructed by calling 
             Query.Constrain().
             
             
             Constraints can be joined with the methods And() and Or().
             
             
             The methods to modify the constraint evaluation algorithm may
             be merged, to construct combined evaluation rules.
             Examples:
             <ul>
               <li> <code>Constraint#Smaller().Equal()</code> for "smaller or equal" </li>
               <li> <code>Constraint#Like().Not()</code> for "not like" </li>
               <li> <code>Constraint#Greater().Equal().Not()</code> for "not greater or equal" </li>
             </ul>
            
             </summary>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.And(NDatabase.Api.Query.IConstraint)">
            <summary>
            Links two IConstrains for AND evaluation. 
            </summary>
            <param name="with">The other IConstraint</param>
            <returns>A new IConstraint, that can be used for further calls to and() and or()</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Or(NDatabase.Api.Query.IConstraint)">
            <summary>
            Links two IConstrains for OR evaluation.
            </summary>
            <param name="with">The other IConstraint</param>
            <returns>A new IConstraint, that can be used for further calls to and() and or()</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Equal">
            <summary>
            Sets the evaluation mode to <code>==</code>.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Greater">
            <summary>
            Sets the evaluation mode to <code>&gt;</code>.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Smaller">
            <summary>
            Sets the evaluation mode to <code>&lt;</code>.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Identity">
            <summary>
            Sets the evaluation mode to identity comparison.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Like">
            <summary>
            Sets the evaluation mode to "like" comparison.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Contains">
            <summary>
            Sets the evaluation mode to containment comparison.
            
            Evaluation is dependant on the constrained query node:
            <dl>
             <dt><code>String</code></dt>
              <dd>the persistent object is tested to contain a substring.</dd>
             <dt>arrays, collections</dt>
              <dd>the persistent object is tested to contain all elements of
                 the constraining object.</dd>
            </dl>
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.Not">
            <summary>
            turns on not() comparison.
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.InvariantLike">
            <summary>
            Sets the evaluation mode to "like" comparison. (Invariant mode)
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeLe">
            <summary>
            Check if size of the collection is less or equal
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeEq">
            <summary>
            Check if size of the collection is equal
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeNe">
            <summary>
            Check if size of the collection is not equal
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeGt">
            <summary>
            Check if size of the collection is greater than
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeGe">
            <summary>
            Check if size of the collection is greater or equal
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.SizeLt">
            <summary>
            Check if size of the collection is less than
            </summary>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.GetObject">
            <summary>
            returns the Object the query graph was constrained with to
            create this IConstraint.
            </summary>
            <returns>The constraining object.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.EndsWith(System.Boolean)">
            <summary>
            Sets evaluation to string ends with
            </summary>
            <param name="isCaseSensitive">Is case sensitive comparison</param>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IConstraint.StartsWith(System.Boolean)">
            <summary>
            Sets evaluation to string starts with
            </summary>
            <param name="isCaseSensitive">Is case sensitive comparison</param>
            <returns>this IConstraint to allow the chaining of method calls.</returns>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.IInternalConstraint.GetAllInvolvedFields">
            <summary>
              to be able to optimize query execution.
            </summary>
            <remarks>
              to be able to optimize query execution. 
              Get only the field involved in the query instead of getting all the object
            </remarks>
            <returns> All involved fields in criteria, List of String </returns>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.IInternalConstraint.Match(System.Object)">
            <summary>
              To check if an object matches this criterion
            </summary>
            <returns> true if object matches the criteria </returns>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.Evaluations.ContainsEvaluation._oid">
            <summary>
              For criteria query on objects, we use the oid of the object instead of the object itself.
            </summary>
            <remarks>
              For criteria query on objects, we use the oid of the object instead of the object itself. 
              So comparison will be done with OID It is faster and avoid the need of the object 
              (class) having to implement Serializable in client server mode
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.Evaluations.IdentityEvaluation._oid">
            <summary>
              For criteria query on objects, we use the oid of the object instead of the object itself.
            </summary>
            <remarks>
              For criteria query on objects, we use the oid of the object instead of the object itself. 
              So comparison will be done with OID It is faster and avoid the need of the object (class) 
              having to implement Serializable in client server mode
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.QueryConstraint._attributeName">
            <summary>
              The name of the attribute involved by this criterion
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.QueryConstraint._query">
            <summary>
              The query containing the criterion
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.QueryConstraint.GetAllInvolvedFields">
            <summary>
              An abstract criterion only restrict one field =&gt; it returns a list of one field!
            </summary>
            <returns> The list of involved field of the criteria </returns>
        </member>
        <member name="T:NDatabase.Api.Query.IValuesQuery">
            <summary>
            Extending query with additional query metrics.
            </summary>
        </member>
        <member name="T:NDatabase.Api.Query.IQuery">
            <summary>
            handle to a node in the query graph.
            
            A node in the query graph can represent multiple 
            classes, one class or an attribute of a class.
            
            The graph 
            is automatically extended with attributes of added constraints 
            (see constrain()) and upon calls to  descend()
            that request nodes that do not yet exist.
            
            References to joined nodes in the query graph can be obtained
            by "walking" along the nodes of the graph with the method 
            descend().
            
            execute()
            evaluates the entire graph against all persistent objects. 
            
            execute() can be called from any Query node
            of the graph. It will return an ObjectSet filled with
            objects of the class/classes that the node, it was called from,
            represents.
            </summary>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Constrain(System.Object)">
            <summary>
            adds a constraint to this node.
            
            If the constraint contains attributes that are not yet
            present in the query graph, the query graph is extended
            accordingly.
            </summary>
            <param name="value">constraint the constraint to be added to this Query.</param>
            <returns>Constraint a new Constraint for this query node.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Execute``1">
            <summary>
            executes the Query.
            </summary>
            <returns>ObjectSet - the result of the Query.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Execute``1(System.Boolean)">
            <summary>
            executes the Query.
            </summary>
            <param name="inMemory">Indicates if all returned data should be loaded to memory (inMemory is true)
            or if the data should be lazy loaded (inMemory to false)</param>
            <returns>ObjectSet - the result of the Query.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Execute``1(System.Boolean,System.Int32,System.Int32)">
            <summary>
            executes the Query.
            </summary>
            <param name="inMemory">Indicates if all returned data should be loaded to memory (inMemory is true)
            or if the data should be lazy loaded (inMemory to false)</param>
            <param name="startIndex">Start index for result page.</param>
            <param name="endIndex">End index for result page.</param>
            <returns>ObjectSet - the result of the Query.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Descend(System.String)">
            <summary>
            returns a reference to a descendant node in the query graph.
            If the node does not exist, it will be created.
            
            Query defined class represented in the query node is tested, whether
            it contains a field with the specified field name. The
            descendant Query node will be created from all possible candidates.
            </summary>
            <param name="attributeName">field path to the descendant.</param>
            <returns>descendant Query node</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.OrderAscending">
            <summary>
            adds an ascending ordering criteria to this node of
            the query graph. Multiple ordering criteria will be applied
            in the order they were called.
            @return this Query object to allow the chaining of method calls.
            </summary>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.OrderDescending">
            <summary>
            adds a descending order criteria to this node of
            the query graph. Multiple ordering criteria will be applied
            in the order they were called.
            @return this Query object to allow the chaining of method calls.
            </summary>
        </member>
        <member name="M:NDatabase.Api.Query.IQuery.Count">
            <summary>
            Return count of filtered elements by defined query
            </summary>
            <returns>Number of filtered elements.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Count(System.String)">
            <summary>
            Counts the objects that matches the specified values query.
            </summary>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to count value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sum(System.String)">
            <summary>
            Sums the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Values query with sum value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sum(System.String,System.String)">
            <summary>
            Sums the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to sum value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Avg(System.String,System.String)">
            <summary>
            Averages the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to avg value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Avg(System.String)">
            <summary>
            Avgs the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Values query with avg value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Max(System.String,System.String)">
            <summary>
            Max for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to max value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Max(System.String)">
            <summary>
            Max for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Values query max value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Field(System.String)">
            <summary>
            Field value for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Values query with field value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Field(System.String,System.String)">
            <summary>
            Field value for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to field value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sublist(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sublists the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection or string).</param>
            <param name="alias">The alias for query value.</param>
            <param name="fromIndex">Start index.</param>
            <param name="size">The size.</param>
            <param name="throwException">if set to <c>true</c> [throws exception].</param>
            <returns>Values query with alias item set to sublist value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sublist(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sublists the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection or string).</param>
            <param name="fromIndex">Start index.</param>
            <param name="size">The size.</param>
            <param name="throwException">if set to <c>true</c> [throws exception].</param>
            <returns>Values query with sublist value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sublist(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Sublists the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection or string).</param>
            <param name="alias">The alias for query value.</param>
            <param name="fromIndex">Start index.</param>
            <param name="toIndex">End index.</param>
            <returns>Values query with alias item set to sublist value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Sublist(System.String,System.Int32,System.Int32)">
            <summary>
            Sublists the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection or string).</param>
            <param name="fromIndex">Start index.</param>
            <param name="toIndex">End index.</param>
            <returns>Values query with sublist value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Size(System.String)">
            <summary>
            Size of the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection).</param>
            <returns>Values query with size value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Size(System.String,System.String)">
            <summary>
            Size of the specified attribute name (collection or string).
            </summary>
            <param name="attributeName">Name of the attribute (collection).</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to size value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.GroupBy(System.String)">
            <summary>
            Groups by the specified field list.
            </summary>
            <param name="fieldList">The fields list.</param>
            <returns>Values query with specified group by.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.SetReturnInstance(System.Boolean)">
            <summary>
            Enables or disables the return instance option.
            </summary>
            <remarks>
            To indicate if query execution must build instances or return object representation, Default value is true(return instance)
            </remarks>
            <param name="returnInstance">if set to <c>true</c> [return instance].</param>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Min(System.String)">
            <summary>
            Min for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Values query with min value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Min(System.String,System.String)">
            <summary>
            Min for the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="alias">The alias for query value.</param>
            <returns>Values query with alias item set to min value.</returns>
        </member>
        <member name="M:NDatabase.Api.Query.IValuesQuery.Execute">
            <summary>
            Gets the values that matches the values query.
            </summary>
            <returns>The list of values that matches the values query.</returns>
        </member>
        <member name="M:NDatabase.Core.IInternalValuesQuery.IsMultiRow">
            <summary>
              To indicate if a query will return one row (for example, sum, average, max and min, or will return more than one row
            </summary>
        </member>
        <member name="M:NDatabase.Core.IInternalValuesQuery.HasOrderBy">
            <summary>
              Returns true if the query has an order by clause
            </summary>
            <returns> true if has an order by flag </returns>
        </member>
        <member name="M:NDatabase.Core.IInternalValuesQuery.GetOrderByType">
            <summary>
            Gets the type of the order by.
            </summary>
            <returns>The type of the order by - NONE, DESC or ASC</returns>
        </member>
        <member name="T:NDatabase.Api.Query.ILinqQuery`1">
            <summary>
            NDatabase Linq Query generic interface
            </summary>
        </member>
        <member name="T:NDatabase.Api.Query.ILinqQuery">
            <summary>
            NDatabase Linq Query interface
            </summary>
        </member>
        <member name="T:NDatabase.Api.Query.ILinqQueryable`1">
            <summary>
            IOrderedQueryable&lt;T&gt; derived interface, Linq
            </summary>
        </member>
        <member name="T:NDatabase.Api.Query.ILinqQueryable">
            <summary>
            IOrderedQueryable derived interface, Linq
            </summary>
        </member>
        <member name="M:NDatabase.Api.Query.ILinqQueryable.GetQuery">
            <summary>
            Get underliying linq query
            </summary>
            <returns>Linq query</returns>
        </member>
        <member name="T:NDatabase.Exceptions.LinqQueryException">
            <summary>
            NDatabase exception raised during processing linq query
            </summary>
        </member>
        <member name="T:NDatabase.Api.IIndexManager">
            <summary>
            Index Manager - allows to give access to class level configuration like adding an index, checking if index exists, rebuilding an index,...
            </summary>
        </member>
        <member name="M:NDatabase.Api.IIndexManager.AddUniqueIndexOn(System.String,System.String[])">
            <param name="indexName"> The name of the index </param>
            <param name="indexFields"> The list of fields of the index. Every field needs to implement IComparable.</param>
        </member>
        <member name="M:NDatabase.Api.IIndexManager.AddIndexOn(System.String,System.String[])">
            <param name="indexName"> The name of the index </param>
            <param name="indexFields"> The list of fields of the index. Every field needs to implement IComparable.</param>
        </member>
        <member name="M:NDatabase.Api.IIndexManager.ExistIndex(System.String)">
            <summary>
              To check if an index exist
            </summary>
            <param name="indexName">Existing index name</param>
        </member>
        <member name="M:NDatabase.Api.IIndexManager.RebuildIndex(System.String)">
            <summary>
            Rebuild existing index
            </summary>
            <param name="indexName">Existing index name</param>
        </member>
        <member name="M:NDatabase.Api.IIndexManager.DeleteIndex(System.String)">
            <summary>
            Delete existing index
            </summary>
            <param name="indexName">Existing index name</param>
        </member>
        <member name="M:NDatabase.Meta.Introspector.IIntrospectionCallback.ObjectFound(System.Object)">
            <summary>
              Called when the introspector find a non native object.
            </summary>
        </member>
        <member name="T:NDatabase.Meta.Introspector.IObjectIntrospector">
            <summary>
              Interface for ObjectInstropector.
            </summary>
        </member>
        <member name="M:NDatabase.Meta.Introspector.IObjectIntrospector.GetMetaRepresentation(System.Object,System.Boolean,System.Collections.Generic.IDictionary{System.Object,NDatabase.Meta.NonNativeObjectInfo},NDatabase.Meta.Introspector.IIntrospectionCallback)">
            <summary>
              retrieve object data
            </summary>
            <param name="object"> The object to get meta representation </param>
            <param name="recursive"> To indicate that introspection must be recursive </param>
            <param name="alreadyReadObjects"> A map with already read object, to avoid cyclic reference problem </param>
            <param name="callback"> </param>
            <returns> The object info </returns>
        </member>
        <member name="T:NDatabase.Meta.AbstractObjectInfo">
            <summary>
              To keep meta informations about an object
            </summary>
        </member>
        <member name="F:NDatabase.Meta.AbstractObjectInfo._odbType">
            <summary>
              The Type of the object
            </summary>
        </member>
        <member name="F:NDatabase.Meta.AbstractObjectInfo.OdbTypeId">
            <summary>
              The Type Id of the object
            </summary>
        </member>
        <member name="T:NDatabase.Meta.ArrayObjectInfo">
            <summary>
              A meta representation of an Array
            </summary>
        </member>
        <member name="T:NDatabase.Meta.NativeObjectInfo">
            <summary>
              To keep info about a native instance
            </summary>
        </member>
        <member name="F:NDatabase.Meta.NativeObjectInfo.TheObject">
            <summary>
              The object being represented
            </summary>
        </member>
        <member name="T:NDatabase.Meta.AtomicNativeObjectInfo">
            <summary>
              To keep info about a native object like int,char, long, Does not include array or collection
            </summary>
        </member>
        <member name="P:NDatabase.Meta.AttributesCache.AttributesById">
            <summary>
              This map is redundant with the field 'attributes', 
              but it is to enable fast access to attributes 
              by id key=attribute Id(Integer), key =ClassAttributeInfo
            </summary>
        </member>
        <member name="P:NDatabase.Meta.AttributesCache.AttributesByName">
            <summary>
              This map is redundant with the field 'attributes', 
              but it is to enable fast access to attributes by name
            </summary>
        </member>
        <member name="T:NDatabase.Meta.AttributeValuesMap">
            <summary>
              A Map to contain values of attributes of an object.
            </summary>
            <remarks>
              A Map to contain values of attributes of an object. 
              It is used to optimize a criteria query execution where ODB , 
              while reading an instance data, tries to retrieve only 
              values of attributes involved in the query instead of reading the entire object.
            </remarks>
        </member>
        <member name="F:NDatabase.Meta.AttributeValuesMap._objectInfoHeader">
            <summary>
              The Object Info Header of the object being represented
            </summary>
        </member>
        <member name="F:NDatabase.Meta.AttributeValuesMap._oid">
            <summary>
              The oid of the object.
            </summary>
            <remarks>
              The oid of the object. This is used when some criteria 
              (example is equalCriterion) is on an object, in this case 
              the comparison is done on the oid of the object and not on the object itself.
            </remarks>
        </member>
        <member name="T:NDatabase.Meta.CIZoneInfo">
            <summary>
              Class keep track of object pointers and number of objects of a class info for a specific zone. 
              For example, to keep track of first committed and last committed object position.
            </summary>
        </member>
        <member name="T:NDatabase.Meta.ClassAttributeInfo">
            <summary>
              to keep informations about an attribute of a class : 
               - Its type
               - its name
               - If it is an index
            </summary>
        </member>
        <member name="T:NDatabase.Meta.ClassInfo">
            <summary>
              A meta representation of a class
            </summary>
        </member>
        <member name="F:NDatabase.Meta.ClassInfo._committed">
            <summary>
              To keep session numbers, number of committed objects,first and last object position
            </summary>
        </member>
        <member name="F:NDatabase.Meta.ClassInfo._fullClassName">
            <summary>
              The full class name with package
            </summary>
        </member>
        <member name="F:NDatabase.Meta.ClassInfo._original">
            <summary>
              To keep session original numbers, original number of committed objects,first and last object position
            </summary>
        </member>
        <member name="F:NDatabase.Meta.ClassInfo._uncommitted">
            <summary>
              To keep session uncommitted numbers, number of uncommitted objects,first and last object position
            </summary>
        </member>
        <member name="M:NDatabase.Meta.ClassInfo.GetAllNonNativeAttributes">
            <summary>
              This method could be optimized, but it is only on Class creation, one time in the database life time...
            </summary>
            <remarks>
              This method could be optimized, but it is only on Class creation, one time in the database life time... 
              This is used to get all (non native) attributes a class info have to store them in the meta model
              before storing the class itself
            </remarks>
        </member>
        <member name="M:NDatabase.Meta.ClassInfo.HasCyclicReference">
            <summary>
              To detect if a class has cyclic reference
            </summary>
            <returns> true if this class info has cyclic references </returns>
        </member>
        <member name="M:NDatabase.Meta.ClassInfo.HasCyclicReference(System.Collections.Generic.IDictionary{System.String,NDatabase.Meta.ClassInfo})">
            <summary>
              To detect if a class has cyclic reference
            </summary>
            <param name="alreadyVisitedClasses"> A dictionary containing all the already visited classes </param>
            <returns> true if this class info has cyclic references </returns>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.AttributesDefinitionPosition">
            <summary>
              Where starts the block of attributes definition of this class ?
            </summary>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.Position">
            <summary>
              Physical location of this class in the file (in byte)
            </summary>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.FullClassName">
            <summary>
              The full class name with namespace
            </summary>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.MaxAttributeId">
            <summary>
              The max id is used to give a unique id for each attribute and allow refactoring like new field and/or removal
            </summary>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.LastObjectInfoHeader">
            <summary>
              Infos about the last object of this class
            </summary>
        </member>
        <member name="P:NDatabase.Meta.ClassInfo.NumberOfObjects">
            <summary>
              Get number of objects: committed and uncommitted
            </summary>
            <value> The number of committed and uncommitted objects </value>
        </member>
        <member name="T:NDatabase.Meta.ClassInfoCompareResult">
            <summary>
              To keep track of differences between two ClassInfo.
            </summary>
            <remarks>
              To keep track of differences between two ClassInfo. Ussed by the MetaModel compatibility checker
            </remarks>
        </member>
        <member name="T:NDatabase.Meta.ClassInfoIndex">
            <summary>
              An index of a class info
            </summary>
        </member>
        <member name="M:NDatabase.Meta.ClassInfoIndex.MatchAttributeIds(System.Int32[])">
            <summary>
              Check if a list of attribute can use the index
            </summary>
            <returns> true if the list of attribute can use this index </returns>
        </member>
        <member name="T:NDatabase.Meta.ClassInfoList">
            <summary>
              A simple list to contain some class infos.
            </summary>
            <remarks>
              A simple list to contain some class infos. 
             <pre>It used by ClassIntropector.introspect to return all the class info detected by introspecting a class.
                  For example, if we have a class Class1 that has a field of type Class2. And Class2 has a field of type Class3.
                  Introspecting Class1 return a ClassInfoList with the classes Class1, Class2, Class3. Class1 being the main class info</pre>
            </remarks>
        </member>
        <member name="M:NDatabase.Meta.ClassInfoList.GetClassInfoBy(System.Type)">
            <returns> null if it does not exist </returns>
        </member>
        <member name="T:NDatabase.Meta.CommittedCIZoneInfo">
            <summary>
              Used for committed zone info.
            </summary>
            <remarks>
              Used for committed zone info. It has one more attribute than the super class. It is used to keep track of committed deleted objects
            </remarks>
        </member>
        <member name="T:NDatabase.Meta.Compare.ChangedObjectInfo">
            <summary>
              Used to store informations about object changes
            </summary>
        </member>
        <member name="T:NDatabase.Meta.EnumNativeObjectInfo">
            <summary>
              Meta representation of an enum.
            </summary>
            <remarks>
              Meta representation of an enum. Which is internally represented by a string : Its name
            </remarks>
        </member>
        <member name="T:NDatabase.Meta.MetaModel">
            <summary>
              The database meta-model
            </summary>
        </member>
        <member name="F:NDatabase.Meta.MetaModel._allClassInfos">
            <summary>
              A simple list to hold all class infos.
            </summary>
            <remarks>
              A simple list to hold all class infos. It is redundant with the maps, but in some cases, we need sequential access to classes :-(
            </remarks>
        </member>
        <member name="F:NDatabase.Meta.MetaModel._changedClasses">
            <summary>
              A list of changed classes - that must be persisted back when commit is done
            </summary>
        </member>
        <member name="F:NDatabase.Meta.MetaModel._hasChanged">
            <summary>
              to identify if meta model has changed
            </summary>
        </member>
        <member name="F:NDatabase.Meta.MetaModel._rapidAccessForClassesByName">
            <summary>
              A hash map to speed up the access of class info by full class name
            </summary>
        </member>
        <member name="M:NDatabase.Meta.MetaModel.GetClassInfoFromId(NDatabase.Api.OID)">
            <summary>
              Gets the class info from the OID.
            </summary>
            <remarks>
              Gets the class info from the OID.
            </remarks>
            <param name="id"> </param>
            <returns> the class info with the OID </returns>
        </member>
        <member name="M:NDatabase.Meta.MetaModel.GetLastClassInfo">
            <returns> The Last class info </returns>
        </member>
        <member name="M:NDatabase.Meta.MetaModel.GetClassInfo(System.Int32)">
            <param name="index"> The index of the class info to get </param>
            <returns> The class info at the specified index </returns>
        </member>
        <member name="M:NDatabase.Meta.MetaModel.AddChangedClass(NDatabase.Meta.ClassInfo)">
            <summary>
              Saves the fact that something has changed in the class (number of objects or last object oid)
            </summary>
        </member>
        <member name="M:NDatabase.Meta.MetaModel.GetPersistentSubclassesOf(System.Type)">
            <summary>
              Gets all the persistent classes that are subclasses or equal to the parameter class
            </summary>
            <returns> The list of class info of persistent classes that are subclasses or equal to the class </returns>
        </member>
        <member name="T:NDatabase.Meta.NativeAttributeHeader">
            <summary>
              A class that contain basic information about a native object
            </summary>
        </member>
        <member name="T:NDatabase.Meta.NonNativeDeletedObjectInfo">
            <summary>
              To specify that an object has been mark as deleted
            </summary>
        </member>
        <member name="T:NDatabase.Meta.NonNativeObjectInfo">
            <summary>
              To keep info about a non native object <pre>- Keeps its class info : a meta information to describe its type
                                                       - All its attributes values
                                                       - Its Pointers : its position, the previous object OID, the next object OID
                                                       - The Object being represented by The meta information</pre>
            </summary>
        </member>
        <member name="F:NDatabase.Meta.NonNativeObjectInfo._theObject">
            <summary>
              The object being represented
            </summary>
        </member>
        <member name="M:NDatabase.Meta.NonNativeObjectInfo.SetValueOf(System.String,NDatabase.Meta.AbstractObjectInfo)">
            <summary>
              Used to change the value of an attribute
            </summary>
            <param name="attributeName"> </param>
            <param name="aoi"> </param>
        </member>
        <member name="M:NDatabase.Meta.NonNativeObjectInfo.CreateCopy(System.Collections.Generic.IDictionary{NDatabase.Api.OID,NDatabase.Meta.AbstractObjectInfo},System.Boolean)">
            <summary>
              Create a copy oh this meta object
            </summary>
            <param name="cache"> </param>
            <param name="onlyData"> if true, only copy attributes values </param>
            <returns> </returns>
        </member>
        <member name="M:NDatabase.Meta.NonNativeDeletedObjectInfo.IsNull">
            <summary>
              A deleted non native object is considered to be null!
            </summary>
        </member>
        <member name="T:NDatabase.Meta.NonNativeNullObjectInfo">
            <summary>
              To keep info about a non native null instance
            </summary>
        </member>
        <member name="T:NDatabase.Meta.NullNativeObjectInfo">
            <summary>
              Meta representation of a null native object
            </summary>
        </member>
        <member name="T:NDatabase.Meta.ObjectInfoHeader">
            <summary>
              Some basic info about an object info like position, its class info,...
            </summary>
        </member>
        <member name="F:NDatabase.Meta.ObjectInfoHeader._attributesIdentification">
            <summary>
              Can be position(for native object) or id(for non native object, positions are positive e ids are negative
            </summary>
        </member>
        <member name="M:NDatabase.Meta.ObjectInfoHeader.GetAttributeIdentificationFromId(System.Int32)">
            <summary>
              Return the attribute identification (position or id) from the attribute id FIXME Remove dependency from StorageEngineConstant
            </summary>
            <param name="attributeId"> </param>
            <returns> -1 if attribute with this id does not exist </returns>
        </member>
        <member name="T:NDatabase.Meta.ObjectReference">
            <summary>
              Meta representation of an object reference.
            </summary>
        </member>
        <member name="M:NDatabase.Meta.ObjectReference.GetOid">
            <returns> Returns the id. </returns>
        </member>
        <member name="T:NDatabase.Meta.OdbType">
            <summary>
              Contains the list for the ODB types
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.ByteId">
            <summary>
              1 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.SByteId">
            <summary>
              1 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.ShortId">
            <summary>
              2 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.UShortId">
            <summary>
              2 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.IntegerId">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.UIntegerId">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.LongId">
            <summary>
              8 bytes
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.ULongId">
            <summary>
              8 bytes
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.FloatId">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.DoubleId">
            <summary>
              8 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.DecimalId">
            <summary>
              16 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.EnumId">
            <summary>
              Enums are internally stored as String: the enum name
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.CacheOfTypesByName">
            <summary>
              This cache is used to cache non default types.
            </summary>
            <remarks>
              This cache is used to cache non default types. 
              Instead or always testing if a class is an array 
              or a collection or any other, we put the odb type in this cache
            </remarks>
        </member>
        <member name="F:NDatabase.Meta.OdbType._subType">
            <summary>
              For array element type
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Byte">
            <summary>
              1 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.SByte">
            <summary>
              1 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Short">
            <summary>
              2 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.UShort">
            <summary>
              2 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Integer">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.UInteger">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Decimal">
            <summary>
              16 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Long">
            <summary>
              8 bytes
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.ULong">
            <summary>
              8 bytes
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Float">
            <summary>
              4 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Double">
            <summary>
              8 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Character">
            <summary>
              2 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Boolean">
            <summary>
              1 byte
            </summary>
        </member>
        <member name="F:NDatabase.Meta.OdbType.Date">
            <summary>
              8 byte
            </summary>
        </member>
        <member name="P:NDatabase.Meta.OidInfo.NextClassOID">
            <summary>
              Where is the next class, -1, if it does not exist
            </summary>
        </member>
        <member name="P:NDatabase.Meta.OidInfo.PreviousClassOID">
            <summary>
              Where is the previous class.
            </summary>
            <remarks>
              Where is the previous class. -1, if it does not exist
            </remarks>
        </member>
        <member name="P:NDatabase.Storage.CurrentIdBlockInfo.CurrentIdBlockMaxOid">
            <summary>
              The max id already allocated in the current id block
            </summary>
        </member>
        <member name="P:NDatabase.Storage.CurrentIdBlockInfo.CurrentIdBlockNumber">
            <summary>
              The current id block number
            </summary>
        </member>
        <member name="P:NDatabase.Storage.CurrentIdBlockInfo.CurrentIdBlockPosition">
            <summary>
              The position of the current block where IDs are stored
            </summary>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.WriteLastOdbCloseStatus(System.Boolean,System.Boolean)">
            <summary>
              Write the status of the last odb close
            </summary>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.WriteNumberOfClasses(System.Int64,System.Boolean)">
            <summary>
              Write the number of classes in meta-model
            </summary>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.WriteFirstClassInfoOID(NDatabase.Api.OID,System.Boolean)">
            <summary>
              Resets the position of the first class of the metamodel.
            </summary>
            <remarks>
              Resets the position of the first class of the metamodel. It Happens when database is being refactored
            </remarks>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.WriteIdBlock(System.Int64,System.Int32,System.Byte,System.Int32,System.Int64,System.Boolean)">
            <summary>
              Writes the header of a block of type ID - a block that contains ids of objects and classes
            </summary>
            <param name="position"> Position at which the block must be written, if -1, take the next available position </param>
            <param name="idBlockSize"> The block size in byte </param>
            <param name="blockStatus"> The block status </param>
            <param name="blockNumber"> The number of the block </param>
            <param name="previousBlockPosition"> The position of the previous block of the same type </param>
            <param name="writeInTransaction"> To indicate if write must be done in transaction </param>
            <returns> The position of the id @ </returns>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.MarkIdBlockAsFull(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Marks a block of type id as full, changes the status and the next block position
            </summary>
            <param name="blockPosition"> </param>
            <param name="nextBlockPosition"> </param>
            <param name="writeInTransaction"> </param>
            <returns> The block position @ </returns>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.CreateEmptyDatabaseHeader(NDatabase.Core.IStorageEngine,System.Int64)">
            <summary>
              Creates the header of the file
            </summary>
            <param name="storageEngine"> </param>
            <param name="creationDate"> The creation date </param>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.AssociateIdToObject(System.Byte,System.Byte,System.Int64,NDatabase.Api.OID,System.Int64,System.Boolean)">
            <summary>
              Associate an object OID to its position
            </summary>
            <param name="idType"> The type : can be object or class </param>
            <param name="idStatus"> The status of the OID </param>
            <param name="currentBlockIdPosition"> The current OID block position </param>
            <param name="oid"> The OID </param>
            <param name="objectPosition"> The position </param>
            <param name="writeInTransaction"> To indicate if write must be executed in transaction </param>
            <returns> @ </returns>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.UpdateObjectPositionForObjectOIDWithPosition(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Updates the real object position of the object OID
            </summary>
            <param name="idPosition"> The OID position </param>
            <param name="objectPosition"> The real object position </param>
            <param name="writeInTransaction"> indicate if write must be done in transaction @ </param>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.UpdateClassPositionForClassOIDWithPosition(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Udates the real class positon of the class OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.UpdateInstanceFieldsOfClassInfo(NDatabase.Meta.ClassInfo,System.Boolean)">
            <summary>
              Updates the instance related field of the class info into the database file Updates the number of objects, the first object oid and the next class oid
            </summary>
            <param name="classInfo"> The class info to be updated </param>
            <param name="writeInTransaction"> To specify if it must be part of a transaction @ </param>
        </member>
        <member name="M:NDatabase.Core.IFileSystemWriter.WriteClassAttributeInfo(NDatabase.Core.IStorageEngine,NDatabase.Meta.ClassAttributeInfo,System.Boolean)">
            <summary>
              Writes a class attribute info, an attribute of a class
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteLastOdbCloseStatus(System.Boolean,System.Boolean)">
            <summary>
              Write the status of the last odb close
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteVersion">
            <summary>
              Write the version in the database file
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.GetDatabaseId(System.Int64)">
            <summary>
              Returns a database id : 4 longs
            </summary>
            <param name="creationDate"> </param>
            <returns> a 4 long array </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteNumberOfClasses(System.Int64,System.Boolean)">
            <summary>
              Write the number of classes in meta-model
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteDatabaseCharacterEncoding">
            <summary>
              Write the database characterEncoding
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteFirstClassInfoOID(NDatabase.Api.OID,System.Boolean)">
            <summary>
              Resets the position of the first class of the metamodel.
            </summary>
            <remarks>
              Resets the position of the first class of the metamodel. It Happens when database is being refactored
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteIdBlock(System.Int64,System.Int32,System.Byte,System.Int32,System.Int64,System.Boolean)">
            <summary>
              Writes the header of a block of type ID - a block that contains ids of objects and classes
            </summary>
            <param name="position"> Position at which the block must be written, if -1, take the next available position </param>
            <param name="idBlockSize"> The block size in byte </param>
            <param name="blockStatus"> The block status </param>
            <param name="blockNumber"> The number of the block </param>
            <param name="previousBlockPosition"> The position of the previous block of the same type </param>
            <param name="writeInTransaction"> To indicate if write must be done in transaction </param>
            <returns> The position of the id @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.MarkIdBlockAsFull(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Marks a block of type id as full, changes the status and the next block position
            </summary>
            <param name="blockPosition"> </param>
            <param name="nextBlockPosition"> </param>
            <param name="writeInTransaction"> </param>
            <returns> The block position @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.CreateEmptyDatabaseHeader(NDatabase.Core.IStorageEngine,System.Int64)">
            <summary>
              Creates the header of the file
            </summary>
            <param name="storageEngine">Storage engine </param>
            <param name="creationDate"> The creation date </param>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.AssociateIdToObject(System.Byte,System.Byte,System.Int64,NDatabase.Api.OID,System.Int64,System.Boolean)">
            <summary>
              Associate an object OID to its position
            </summary>
            <param name="idType"> The type : can be object or class </param>
            <param name="idStatus"> The status of the OID </param>
            <param name="currentBlockIdPosition"> The current OID block position </param>
            <param name="oid"> The OID </param>
            <param name="objectPosition"> The position </param>
            <param name="writeInTransaction"> To indicate if write must be executed in transaction </param>
            <returns> @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.UpdateObjectPositionForObjectOIDWithPosition(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Updates the real object position of the object OID
            </summary>
            <param name="idPosition"> The OID position </param>
            <param name="objectPosition"> The real object position </param>
            <param name="writeInTransaction"> indicate if write must be done in transaction @ </param>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.UpdateClassPositionForClassOIDWithPosition(System.Int64,System.Int64,System.Boolean)">
            <summary>
              Udates the real class positon of the class OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.UpdateInstanceFieldsOfClassInfo(NDatabase.Meta.ClassInfo,System.Boolean)">
            <summary>
              Updates the instance related field of the class info into the database file Updates the number of objects, the first object oid and the next class oid
            </summary>
            <param name="classInfo"> The class info to be updated </param>
            <param name="writeInTransaction"> To specify if it must be part of a transaction @ </param>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemWriter.WriteClassAttributeInfo(NDatabase.Core.IStorageEngine,NDatabase.Meta.ClassAttributeInfo,System.Boolean)">
            <summary>
              Writes a class attribute info, an attribute of a class
            </summary>
        </member>
        <member name="T:NDatabase.Core.Engine.StorageEngine">
            <summary>
              The storage Engine. The Local Storage Engine class in the most important class in ODB.
            </summary>
            <remarks>
              The storage Engine <pre>The Local Storage Engine class in the most important class in ODB. It manages reading, writing and querying objects.
                                   All write operations are delegated to the ObjectWriter class.
                                   All read operations are delegated to the ObjectReader class.
                                   All Id operations are delegated to the IdManager class.
                                   All Introspecting operations are delegated to the ObjectIntrospector class.
                                   All Trigger operations are delegated to the TriggerManager class.
                                   All session related operations are executed by The Session class. Session Class using the Transaction
                                   class are responsible for ACID behavior.</pre>
            </remarks>
        </member>
        <member name="T:NDatabase.Core.IStorageEngine">
            <summary>
              The interface of all that a StorageEngine (Main concept in ODB) must do.
            </summary>
        </member>
        <member name="M:NDatabase.Core.IStorageEngine.Store``1(``0)">
            <summary>
              Store an object in an database.
            </summary>
            <remarks>
              Store an object in an database. To detect if object must be updated or insert, we use the cache. To update an object, it must be first selected from the database. When an object is to be stored, if it exist in the cache, then it will be updated, else it will be inserted as a new object. If the object is null, the cache will be used to check if the meta representation is in the cache
            </remarks>
        </member>
        <member name="M:NDatabase.Core.IStorageEngine.AddIndexOn(System.String,System.String,System.String[],System.Boolean)">
            <param name="className"> The class name on which the index must be created </param>
            <param name="name"> The name of the index </param>
            <param name="indexFields"> The list of fields of the index </param>
            <param name="acceptMultipleValuesForSameKey"> </param>
        </member>
        <member name="M:NDatabase.Core.IStorageEngine.GetRefactorManager">
            <summary>
              Returns the object used to refactor the database
            </summary>
        </member>
        <member name="M:NDatabase.Core.IStorageEngine.Disconnect``1(``0)">
            <summary>
              Used to disconnect the object from the current session.
            </summary>
            <remarks>
              Used to disconnect the object from the current session. The object is removed from the cache
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Engine.AbstractStorageEngineReader.DbIdentification">
            <summary>
                The file parameters - if we are accessing a file, it will be a IOFileParameters that contains the file name
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.AbstractStorageEngineReader.IsDbClosed">
            <summary>
                To check if database has already been closed
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.AbstractStorageEngineReader.RebuildIndex(System.String,System.String)">
            <summary>
                Used to rebuild an index
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.StorageEngine._introspectionCallbackForInsert">
            <summary>
              This is a visitor used to execute some specific action(like calling 'Before Insert Trigger') when introspecting an object
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.StorageEngine._introspectionCallbackForUpdate">
            <summary>
              This is a visitor used to execute some specific action when introspecting an object
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.StorageEngine.#ctor(NDatabase.IO.IDbIdentification)">
            <summary>
              The database file name
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.StorageEngine.DeleteObjectWithOid(NDatabase.Api.OID)">
            <summary>
              Warning,
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.StorageEngine.Delete``1(``0)">
            <summary>
              Actually deletes an object database
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.StorageEngine.InternalStore``1(NDatabase.Api.OID,``0)">
            <summary>
              Store an object with the specific id
            </summary>
            <param name="oid"> </param>
            <param name="plainObject"> </param>
        </member>
        <member name="M:NDatabase.Core.Engine.StorageEngine.ToString">
            <summary>
              Returns a string of the meta-model
            </summary>
            <returns> The engine description </returns>
        </member>
        <member name="T:NDatabase.Core.Engine.FileSystemInterface">
            <summary>
              Class that knows how to read/write all language native types : byte, char, String, int, long,....
            </summary>
        </member>
        <member name="M:NDatabase.Core.IFileSystemInterface.SetWritePositionNoVerification(System.Int64,System.Boolean)">
            <summary>
              Does the same thing than setWritePosition, but do not control write position
            </summary>
            <param name="position"> </param>
            <param name="writeInTransacation"> </param>
        </member>
        <member name="M:NDatabase.Core.IFileSystemInterface.GetFileIdentification">
            <returns> Returns the parameters. </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemInterface.IsWritingInWrongPlace(System.Int64)">
            <summary>
              Writing at position &lt; DATABASE_HEADER_PROTECTED_ZONE_SIZE is writing in ODB Header place.
            </summary>
            <remarks>
              Writing at position &lt; DATABASE_HEADER_PROTECTED_ZONE_SIZE is writing in ODB Header place. 
              Here we check the positions where the writing is done. 
              Search for 'page format' in ODB wiki to understand the positions
            </remarks>
            <param name="position"> </param>
            <returns> </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.FileSystemInterface.EnsureSpaceFor(System.Int64,NDatabase.Meta.OdbType)">
            <summary>
              Reserve space in the file when it is at the end of the file Used in transaction mode where real write will happen later
            </summary>
            <param name="quantity"> The number of object to reserve space for </param>
            <param name="type"> The type of the object to reserve space for </param>
        </member>
        <member name="T:NDatabase.IO.IMultiBufferedFileIO">
            <summary>
              The interface for buffered IO
            </summary>
        </member>
        <member name="T:NDatabase.Meta.IdTypes">
            <summary>
              ID types are used for classes(class id) and objects(Object Id) to specify the type of the id in the ID blocks
            </summary>
        </member>
        <member name="M:NDatabase.Oid.IIdManager.GetNextObjectId(System.Int64)">
            <summary>
              Gets an id for an object (instance)
            </summary>
            <param name="objectPosition"> the object position (instance) </param>
            <returns> The id </returns>
        </member>
        <member name="M:NDatabase.Oid.IIdManager.GetNextClassId(System.Int64)">
            <summary>
              Gets an id for a class
            </summary>
            <param name="objectPosition"> the object position (class) </param>
            <returns> The id </returns>
        </member>
        <member name="M:NDatabase.Oid.IIdManager.MustShift">
            <summary>
              To check if the id block must shift: that a new id block must be created
            </summary>
            <returns> a boolean value to check if block of id is full </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.ReadDatabaseHeader">
            <summary>
              Reads the database header
            </summary>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.LoadMetaModel(NDatabase.Meta.IMetaModel,System.Boolean)">
            <summary>
              Reads the database meta model
            </summary>
            <param name="metaModel"> An empty meta model </param>
            <param name="full"> To indicate if a full read must be done </param>
            <returns> The modified metamodel </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.ReadObjectInfoValuesFromOID(NDatabase.Meta.ClassInfo,NDatabase.Api.OID,System.Boolean,NDatabase.Tool.Wrappers.IOdbList{System.String},NDatabase.Tool.Wrappers.IOdbList{System.String},System.Int32)">
            <summary>
              reads some attributes of an object.
            </summary>
            <remarks>
              reads some attributes of an object. <pre>example of method call
                                                    readObjectInfoValues(classinfo,18000,true,[&quot;profile.name&quot;,&quot;profile.email&quot;],[&quot;profile.name&quot;,&quot;profile.email&quot;],0)
                                                    readObjectInfoValues(classinfo,21789,true,[&quot;name&quot;],[&quot;profile.name&quot;],1)</pre>
            </remarks>
            <param name="classInfo"> If null, we are probably reading a native instance : String for example </param>
            <param name="oid"> The oid of the object to read. if -1,the read will be done by position </param>
            <param name="useCache"> To indicate if cache must be used. If not, the old version of the object will read </param>
            <param name="attributeNames"> The names of attributes to read the values, an attributename can contain relation like profile.name </param>
            <param name="relationAttributeNames"> The original names of attributes to read the values, an attributename can contain relation like profile.name </param>
            <param name="recursionLevel"> The recursion level of this method call </param>
            <returns> The map with attribute values </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetObjects``1(NDatabase.Api.Query.IQuery,System.Boolean,System.Int32,System.Int32)">
            <summary>
              Get a list of object matching the query
            </summary>
            <param name="query"> </param>
            <param name="inMemory"> </param>
            <param name="startIndex"> </param>
            <param name="endIndex"> </param>
            <returns> The list of objects </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetValues(NDatabase.Core.IInternalValuesQuery,System.Int32,System.Int32)">
            <summary>
              Get a list of values matching the query
            </summary>
            <param name="query"> </param>
            <param name="startIndex"> </param>
            <param name="endIndex"> </param>
            <returns> The list of values </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetObjectInfos``1(NDatabase.Api.Query.IQuery,System.Boolean,System.Int32,System.Int32,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              Return Objects.
            </summary>
            <remarks>
              Return Objects. Match the query without instantiating objects. Only instantiate object for object that match the query
            </remarks>
            <param name="query"> The query to select objects </param>
            <param name="inMemory"> To indicate if object must be all loaded in memory </param>
            <param name="startIndex"> First object index </param>
            <param name="endIndex"> Last object index </param>
            <param name="returnObjects"> To indicate if object instances must be created </param>
            <param name="queryResultAction"> </param>
            <returns> The list of objects </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.ReadObjectInfoHeaderFromOid(NDatabase.Api.OID,System.Boolean)">
            <summary>
              Reads the pointers(ids or positions) of an object that has the specific oid
            </summary>
            <param name="oid"> The oid of the object we want to read the pointers </param>
            <param name="useCache"> </param>
            <returns> The ObjectInfoHeader </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetAllIds(System.Byte)">
            <summary>
              Returns information about all OIDs of the database
            </summary>
            <param name="idType"> </param>
            <returns> </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetNextObjectOID(NDatabase.Api.OID)">
            <summary>
              Gets the next object oid of the object with the specific oid
            </summary>
            <param name="oid"> </param>
            <returns> The oid of the next object. If there is no next object, return null </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.GetObjectPositionFromItsOid(NDatabase.Api.OID,System.Boolean,System.Boolean)">
            <summary>
              Gets the real object position from its OID
            </summary>
            <param name="oid"> The oid of the object to get the position To indicate if an exception must be thrown if object is not found </param>
            <param name="useCache"> </param>
            <param name="throwException"> </param>
            <returns> The object position, if object has been marked as deleted then return StorageEngineConstant.DELETED_OBJECT_POSITION </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectReader.ReadNonNativeObjectInfoFromPosition(NDatabase.Meta.ClassInfo,NDatabase.Api.OID,System.Int64,System.Boolean,System.Boolean)">
            <summary>
              Reads a non non native Object Info (Layer2) from its position
            </summary>
            <param name="classInfo"> </param>
            <param name="oid"> can be null </param>
            <param name="position"> </param>
            <param name="useCache"> </param>
            <param name="returnInstance"> </param>
            <returns> The meta representation of the object </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.InsertNonNativeObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <param name="oid"> The Oid of the object to be inserted </param>
            <param name="nnoi"> The object meta representation The object to be inserted in the database </param>
            <param name="isNewObject"> To indicate if object is new </param>
            <returns> The position of the inserted object </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.UpdateNonNativeObjectInfo(NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <summary>
              Updates an object.
            </summary>
            <remarks>
              Updates an object. Deletes the current object and creates a new at the end of the database file and updates
                                   OID object position.
            </remarks>
            <param name="nnoi"> The meta representation of the object to be updated </param>
            <param name="forceUpdate"> when true, no verification is done to check if update must be done. </param>
            <returns> The oid of the object, as a negative number </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.CreateEmptyDatabaseHeader(System.Int64)">
            <summary>
              Creates the header of the file
            </summary>
            <param name="creationDate"> The creation date </param>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.UpdatePreviousObjectFieldOfObjectInfo(NDatabase.Api.OID,NDatabase.Api.OID,System.Boolean)">
            <summary>
              Updates the previous object position field of the object at objectPosition
            </summary>
            <param name="objectOID"> </param>
            <param name="previousObjectOID"> </param>
            <param name="writeInTransaction"> </param>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.UpdateNextObjectFieldOfObjectInfo(NDatabase.Api.OID,NDatabase.Api.OID,System.Boolean)">
            <summary>
              Update next object oid field of the object at the specific position
            </summary>
            <param name="objectOID"> </param>
            <param name="nextObjectOID"> </param>
            <param name="writeInTransaction"> </param>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.MarkAsDeleted(System.Int64,System.Boolean)">
            <summary>
              Mark a block as deleted
            </summary>
            <returns> The block size </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.ManageNewObjectPointers(NDatabase.Meta.NonNativeObjectInfo,NDatabase.Meta.ClassInfo)">
            <summary>
              Updates pointers of objects, Only changes uncommitted info pointers
            </summary>
            <param name="objectInfo"> The meta representation of the object being inserted </param>
            <param name="classInfo"> The class of the object being inserted </param>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.InternalStoreObject(NDatabase.Meta.NativeObjectInfo)">
            <summary>
              Store a meta representation of a native object(already as meta representation)in ODBFactory database.
            </summary>
            <remarks>
              Store a meta representation of a native object(already as meta representation)in ODBFactory database. A Native object is an object that use native language type, String for example To detect if object must be updated or insert, we use the cache. To update an object, it must be first selected from the database. When an object is to be stored, if it exist in the cache, then it will be updated, else it will be inserted as a new object. If the object is null, the cache will be used to check if the meta representation is in the cache
            </remarks>
            <param name="noi"> The meta representation of an object </param>
            <returns> The object position @ </returns>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.ManageIndexesForInsert(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo)">
            <summary>
              Insert the object in the index
            </summary>
            <param name="oid"> The object id </param>
            <param name="nnoi"> The object meta represenation </param>
        </member>
        <member name="M:NDatabase.Core.IObjectWriter.StoreObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo)">
            <summary>
              Store a meta representation of an object(already as meta representation)in ODBFactory database.
            </summary>
            <remarks>
              Store a meta representation of an object(already as meta representation)in ODBFactory database. To detect if object must be updated or insert, we use the cache. To update an object, it must be first selected from the database. When an object is to be stored, if it exist in the cache, then it will be updated, else it will be inserted as a new object. If the object is null, the cache will be used to check if the meta representation is in the cache
            </remarks>
            <param name="oid"> The oid of the object to be inserted/updates </param>
            <param name="nnoi"> The meta representation of an object </param>
            <returns> The object position </returns>
        </member>
        <member name="T:NDatabase.IO.FileIdentification">
            <summary>
              Database Parameters for local database access
            </summary>
        </member>
        <member name="P:NDatabase.IO.IMultiBuffer.MaxPositionInBuffer">
            <summary>
              The max position in the buffer, used to optimize the flush - to flush only new data and not all the buffer
            </summary>
        </member>
        <member name="P:NDatabase.IO.IMultiBuffer.Size">
            <summary>
              The buffer size.
            </summary>
        </member>
        <member name="T:NDatabase.Api.IRefactorManager">
            <summary>
              <p>An interface for refactoring</p>
            </summary>
        </member>
        <member name="M:NDatabase.Api.IRefactorManager.RenameClass(System.String,System.Type)">
            <summary>
            Rename stored class - refactoring
            </summary>
            <param name="fullClassName">Old class name</param>
            <param name="newType">New type to apply</param>
        </member>
        <member name="M:NDatabase.Api.IRefactorManager.RenameField(System.Type,System.String,System.String)">
            <summary>
            Rename field of stored class - refactoring
            </summary>
            <param name="type">Type of the class</param>
            <param name="attributeName">Old attribute name</param>
            <param name="newAttributeName">New attribute name</param>
        </member>
        <member name="M:NDatabase.Api.IRefactorManager.AddField(System.Type,System.Type,System.String)">
            <summary>
            Extend stored class by new field - refactoring
            </summary>
            <param name="type">Type of the class</param>
            <param name="fieldType">New field type</param>
            <param name="fieldName">New field name</param>
        </member>
        <member name="M:NDatabase.Api.IRefactorManager.RemoveField(System.Type,System.String)">
            <summary>
            Remove field from stored class - refactoring
            </summary>
            <param name="type">Type of field to remove</param>
            <param name="attributeName">Name of field to remove</param>
        </member>
        <member name="T:NDatabase.Exceptions.NDatabaseError">
            <summary>
              All NDatabase ODB Errors.
            </summary>
            <remarks>
              All NDatabase ODB Errors. Errors can be user errors or Internal errors. All @1 in error description will be replaced by parameters
            </remarks>
        </member>
        <member name="M:NDatabase.Exceptions.NDatabaseError.ToString">
            <summary>
              replace the @1,@2,...
            </summary>
            <remarks>
              replace the @1,@2,... by their real values.
            </remarks>
        </member>
        <member name="T:NDatabase.OIDFactory">
            <summary>
            Factory class to create OIDs
            </summary>
        </member>
        <member name="M:NDatabase.OIDFactory.BuildObjectOID(System.Int64)">
            <summary>
            Build object oid based on long number
            </summary>
            <param name="oid">long number as the base for OID</param>
            <returns>Newly created OID</returns>
        </member>
        <member name="M:NDatabase.OIDFactory.BuildClassOID(System.Int64)">
            <summary>
            Build class oid based on long number
            </summary>
            <param name="oid">long number as the base for OID</param>
            <returns>Newly created OID</returns>
        </member>
        <member name="T:NDatabase.Api.OrderByConstants">
            <summary>
              Constants used for ordering queries and creating ordered collection iterators
            </summary>
        </member>
        <member name="F:NDatabase.Api.OrderByConstants.OrderByNone">
            <summary>
            No order
            </summary>
        </member>
        <member name="F:NDatabase.Api.OrderByConstants.OrderByDesc">
            <summary>
            Descending order
            </summary>
        </member>
        <member name="F:NDatabase.Api.OrderByConstants.OrderByAsc">
            <summary>
            Ascending order
            </summary>
        </member>
        <member name="M:NDatabase.Api.OrderByConstants.IsOrderByDesc">
            <summary>
            Is descending order
            </summary>
            <returns>True if descending, false if not</returns>
        </member>
        <member name="M:NDatabase.Api.OrderByConstants.IsOrderByAsc">
            <summary>
            Is ascending order
            </summary>
            <returns>True if ascending, false if not</returns>
        </member>
        <member name="M:NDatabase.Api.OrderByConstants.IsOrderByNone">
            <summary>
            Is no order set
            </summary>
            <returns>True if no order set, false if not</returns>
        </member>
        <member name="M:NDatabase.Core.Query.IInternalQuery.HasOrderBy">
            <summary>
              Returns true if the query has an order by clause
            </summary>
            <returns> true if has an order by flag </returns>
        </member>
        <member name="M:NDatabase.Core.Query.IInternalQuery.GetOrderByFieldNames">
            <summary>
              Returns the field names of the order by
            </summary>
            <returns> The array of fields of the order by </returns>
        </member>
        <member name="M:NDatabase.Core.Query.IInternalQuery.GetOrderByType">
            <returns> the type of the order by - NONE, DESC, ASC </returns>
        </member>
        <member name="F:NDatabase.Core.Query.AbstractQuery._oidOfObjectToQuery">
            <summary>
              The OID attribute is used when the query must be restricted the object with this OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.AbstractQuery.IsForSingleOid">
            <summary>
              Returns true is query must apply on a single object OID
            </summary>
        </member>
        <member name="T:NDatabase.Indexing.ComposedCompareKey">
            <summary>
              A composed key : an object that contains various values used for indexing query result 
              <p>This is an implementation that allows compare keys to contain more than one single value to be compared</p>
            </summary>
        </member>
        <member name="T:NDatabase.Api.IOdbComparable">
            <summary>
            NDatabase wrapper to the native Comparable interface
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Criteria.GenericQueryExecutor">
            <summary>
              <p>Generic query executor</p> .
            </summary>
            <remarks>
              <p>Generic query executor. This class does all the job of iterating in the
                object list and call particular query matching to check if the object must be
                included in the query result.</p> <p>If the query has index, An execution plan is calculated to optimize the
                                                    execution. The query execution plan is calculated by subclasses (using
                                                    abstract method getExecutionPlan).</p>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Query.IQueryExecutor.Execute``1(System.Boolean,System.Int32,System.Int32,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              The main query execution method
            </summary>
            <param name="inMemory"> </param>
            <param name="startIndex"> </param>
            <param name="endIndex"> </param>
            <param name="returnObjects"> </param>
            <param name="queryResultAction"> </param>
            <returns> </returns>
            <exception cref="T:System.Exception">System.Exception</exception>
        </member>
        <member name="M:NDatabase.Core.Query.Execution.IMultiClassQueryExecutor.SetClassInfo(NDatabase.Meta.ClassInfo)">
            <summary>
              The class on which to execute the query
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ObjectReader">
            <summary>
              The object used to read object data from database
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.Query">
            <summary>
              The query being executed
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.Session">
            <summary>
              The current database session
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.StorageEngine">
            <summary>
              The storage engine
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ClassInfo">
            <summary>
              The class of the object being fetched
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor.NextOID">
            <summary>
              The next object position
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor._executeStartAndEndOfQueryAction">
            <summary>
              Used for multi class executor to indicate not to execute start and end method of query result action
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor._orderByKey">
            <summary>
              The key for ordering
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.GenericQueryExecutor._queryHasOrderBy">
            <summary>
              A boolean to indicate if query must be ordered
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ExecuteStartAndEndOfQueryAction">
            <summary>
              Used to indicate if the execute method must call start and end method of the queryResultAction.
            </summary>
            <remarks>
              Used to indicate if the execute method must call start and end method of the queryResultAction. The default is yes. For MultiClass Query executor, it is set to false to avoid to reset the result
            </remarks>
            <returns> true or false to indicate if start and end method of queryResultAction must be executed </returns>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.GetCurrentObjectMetaRepresentation">
            <summary>
              This can be a NonNAtiveObjectInf or AttributeValuesMap
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.MatchObjectWithOid(NDatabase.Api.OID,System.Boolean,System.Boolean)">
            <summary>
              Check if the object with oid matches the query, returns true This method must compute the next object oid and the orderBy key if it exists!
            </summary>
            <param name="oid"> The object position </param>
            <param name="loadObjectInfo"> To indicate if object must loaded (when the query indicator 'in memory' is false, we do not need to load object, only ids) </param>
            <param name="inMemory"> To indicate if object must be actually loaded to memory </param>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ComputeIndexKey(NDatabase.Meta.ClassInfoIndex)">
            <summary>
              Take the fields of the index and take value from the query
            </summary>
            <param name="index"> The index </param>
            <returns> The key of the index </returns>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ExecuteFullScan``1(System.Boolean,System.Int32,System.Int32,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              Query execution full scan <pre>startIndex &amp; endIndex
                                          A B C D E F G H I J K L
                                          [1,3] : nb &gt;=1 &amp;&amp; nb&lt;3
                                          1)
                                          analyze A
                                          nb = 0
                                          nb E [1,3] ? no
                                          r=[]
                                          2)
                                          analyze B
                                          nb = 1
                                          nb E [1,3] ? yes
                                          r=[B]
                                          3) analyze C
                                          nb = 2
                                          nb E [1,3] ? yes
                                          r=[B,C]
                                          4) analyze C
                                          nb = 3
                                          nb E [1,3] ? no and 3&gt; upperBound([1,3]) =&gt; exit</pre>
            </summary>
            <param name="inMemory"> </param>
            <param name="startIndex"> </param>
            <param name="endIndex"> </param>
            <param name="returnObjects"> </param>
            <param name="queryResultAction"> </param>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ExecuteUsingIndex``1(NDatabase.Meta.ClassInfoIndex,System.Boolean,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              Execute query using index
            </summary>
            <param name="index"> </param>
            <param name="inMemory"> </param>
            <param name="returnObjects"> </param>
            <param name="queryResultAction"> </param>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.GenericQueryExecutor.ExecuteForOneOid``1(System.Boolean,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              Execute query using index
            </summary>
            <param name="inMemory"> </param>
            <param name="returnObjects"> </param>
            <param name="queryResultAction"> </param>
        </member>
        <member name="T:NDatabase.Core.IMatchingObjectAction">
            <summary>
              The interface used to implement the classes that are called by the generic query executor when an object matches the query
            </summary>
        </member>
        <member name="M:NDatabase.Core.IMatchingObjectAction.Start">
            <summary>
              Called at the beginning of the query execution - used to prepare result object
            </summary>
        </member>
        <member name="M:NDatabase.Core.IMatchingObjectAction.ObjectMatch(NDatabase.Api.OID,NDatabase.Api.IOdbComparable)">
            <summary>
              Called (by the GenericQueryExecutor) when an object matches with lazy loading, only stores the OID
            </summary>
        </member>
        <member name="M:NDatabase.Core.IMatchingObjectAction.ObjectMatch(NDatabase.Api.OID,System.Object,NDatabase.Api.IOdbComparable)">
            <summary>
              Called (by the GenericQueryExecutor) when an object matches the query
            </summary>
        </member>
        <member name="M:NDatabase.Core.IMatchingObjectAction.End">
            <summary>
              Called at the end of the query execution - used to clean or finish some task
            </summary>
        </member>
        <member name="M:NDatabase.Core.IMatchingObjectAction.GetObjects``1">
            <summary>
              Returns the resulting objects
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Execution.IQueryFieldAction">
            <summary>
              Used to implement generic action on matching object.
            </summary>
            <remarks>
              Used to implement generic action on matching object.
              The Generic query executor is responsible for checking if 
              an object meets the criteria conditions. Then an(some) object 
              actions are called to execute what must be done with matching 
              objects. A ValuesQuery can contain more than one QueryFieldAction.
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Query.Execution.IQueryFieldAction.IsMultiRow">
            <summary>
              To indicate if a query will return one row (for example, sum, average, max and min, or will return more than one row
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Execution.MultiClassGenericQueryExecutor">
            <summary>
              <p>A class to execute a query on more than one class and then merges the result.</p>
            </summary>
            <remarks>
              <p>A class to execute a query on more than one class and then merges the result. It is used when polymophic is set to true because
                in this case, we must execute query on the main class and all its persistent subclasses</p>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Query.Execution.MultiClassGenericQueryExecutor.Execute``1(System.Boolean,System.Int32,System.Int32,System.Boolean,NDatabase.Core.IMatchingObjectAction)">
            <summary>
              The main query execution method
            </summary>
            <param name="inMemory"> </param>
            <param name="startIndex"> </param>
            <param name="endIndex"> </param>
            <param name="returnObjects"> </param>
            <param name="queryResultAction"> </param>
        </member>
        <member name="M:NDatabase.Core.Query.QueryManager.GetQueryExecutor(NDatabase.Api.Query.IQuery,NDatabase.Core.IStorageEngine)">
            <summary>
              Returns a multi class query executor (polymorphic = true)
            </summary>
        </member>
        <member name="T:NDatabase.Indexing.SimpleCompareKey">
            <summary>
              A simple compare key : an object that contains various values used for indexing query result <p></p>
            </summary>
        </member>
        <member name="M:NDatabase.Cache.IOdbCache.SavePositionOfObjectWithOid(NDatabase.Api.OID,System.Int64)">
            <summary>
              To resolve uncommitted updates where the oid change and is not committed yet
            </summary>
        </member>
        <member name="T:NDatabase.Cache.IReadObjectsCache">
            <summary>
              An interface for temporary cache
            </summary>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.Clear">
            <summary>
              clear the transaction
            </summary>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.Commit">
            <summary>
              Execute the commit process of the transaction
            </summary>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.ManageWriteAction(System.Int64,System.Byte[])">
            <summary>
              The public method to add a write action to the transaction.
            </summary>
            <remarks>
              The public method to add a write action to the transaction. If first checks if the new write action action can be appended to the current write action. It is done by checking the currentWritePositioninWA. If yes (position==currentPositioninWA, just append the WA. If not, adds the current one to the transaction and creates a new one (as current)
            </remarks>
            <param name="position"> </param>
            <param name="bytes"> </param>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.GetNumberOfWriteActions">
            <returns> Returns the numberOfWriteActions. </returns>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.SetWritePosition(System.Int64)">
            <summary>
              Set the write position (position in main database file).
            </summary>
            <remarks>
              Set the write position (position in main database file). This is used to know if the next write can be appended to the previous one (in the same current Write Action) or not.
            </remarks>
            <param name="position"> </param>
        </member>
        <member name="M:NDatabase.Core.Session.ITransaction.Reset">
            <summary>
              Reset the transaction
            </summary>
        </member>
        <member name="T:NDatabase.Api.Triggers.DeleteTrigger">
            <summary>
            Abstract class - derive from it if you want to create delete trigger
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.DeleteTrigger.BeforeDelete(System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen before delete
            </summary>
            <param name="object">Deleted object</param>
            <param name="oid">Oid of deleted object</param>
            <returns>True if object was deleted, false if not</returns>
        </member>
        <member name="M:NDatabase.Api.Triggers.DeleteTrigger.AfterDelete(System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen after delete
            </summary>
            <param name="object">Deleted object</param>
            <param name="oid">Oid of deleted object</param>
        </member>
        <member name="T:NDatabase.Api.Triggers.InsertTrigger">
            <summary>
            Abstract class - derive from it if you want to create insert trigger
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.InsertTrigger.BeforeInsert(System.Object)">
            <summary>
            Action which will happen before insert
            </summary>
            <param name="object">Inserted object</param>
            <returns>True if object inserted, false in other case</returns>
        </member>
        <member name="M:NDatabase.Api.Triggers.InsertTrigger.AfterInsert(System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen after insert
            </summary>
            <param name="object">Inserted object</param>
            <param name="oid">Oid of inserted object</param>
        </member>
        <member name="T:NDatabase.Api.Triggers.UpdateTrigger">
            <summary>
            Abstract class - derive from it if you want to create update trigger
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.UpdateTrigger.BeforeUpdate(NDatabase.Api.IObjectRepresentation,System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen before update
            </summary>
            <param name="oldObjectRepresentation">Object representation</param>
            <param name="newObject">Updated object</param>
            <param name="oid">Oid of updated object</param>
            <returns>True if updated, in other case false</returns>
        </member>
        <member name="M:NDatabase.Api.Triggers.UpdateTrigger.AfterUpdate(NDatabase.Api.IObjectRepresentation,System.Object,NDatabase.Api.OID)">
            <summary>
            Action which will happen after update
            </summary>
            <param name="oldObjectRepresentation">Object representation</param>
            <param name="newObject">Updated object</param>
            <param name="oid">Oid of updated object</param>
        </member>
        <member name="T:NDatabase.Exceptions.CorruptedDatabaseException">
            <summary>
              An exception thrown by ODB when a corrupted block is found
            </summary>
        </member>
        <member name="T:NDatabase.Api.IDatabaseId">
            <summary>
            Database identification
            </summary>
        </member>
        <member name="M:NDatabase.Api.IDatabaseId.GetIds">
            <summary>
            Long numbers identifing database
            </summary>
            <returns>Array of long numbers which identifies the database</returns>
        </member>
        <member name="T:NDatabase.Api.IExternalOID">
            <summary>
            External OID, which contains database id
            </summary>
        </member>
        <member name="T:NDatabase.Api.OID">
            <summary>
            Object ID interface
            </summary>
        </member>
        <member name="P:NDatabase.Api.OID.ObjectId">
            <summary>
            Underlying long number - oid
            </summary>
        </member>
        <member name="M:NDatabase.Api.IExternalOID.GetDatabaseId">
            <summary>
            Get database id
            </summary>
            <returns>Database Id</returns>
        </member>
        <member name="T:NDatabase.Core.BTree.LazyOdbBtreeIteratorMultiple`1">
            <summary>
              A Lazy BTree Iterator : It iterate on the object OIDs and lazy load objects from them (OIDs) Used by the LazyBTreeCollection
            </summary>
        </member>
        <member name="M:NDatabase.Core.BTree.LazyOdbBtreeIteratorMultiple`1.#ctor(NDatabase.Btree.IBTree,NDatabase.Api.OrderByConstants,NDatabase.Core.IStorageEngine,System.Boolean)">
            <param name="tree"> </param>
            <param name="orderByType"> </param>
            <param name="storageEngine"> </param>
            <param name="returnObjects"> </param>
        </member>
        <member name="T:NDatabase.Core.BTree.LazyOdbBtreePersister">
            <summary>
              Class that persists the BTree and its node into the NDatabase ODB Database.
            </summary>
        </member>
        <member name="F:NDatabase.Core.BTree.LazyOdbBtreePersister._engine">
            <summary>
              The odb interface
            </summary>
        </member>
        <member name="F:NDatabase.Core.BTree.LazyOdbBtreePersister._modifiedObjectOidList">
            <summary>
              The list is used to keep the order.
            </summary>
            <remarks>
              The list is used to keep the order. Deleted object will be replaced by null value, to keep the positions
            </remarks>
        </member>
        <member name="F:NDatabase.Core.BTree.LazyOdbBtreePersister._modifiedObjectOids">
            <summary>
              All modified nodes : the map is used to avoid duplication The key is the oid, the value is the position is the list
            </summary>
        </member>
        <member name="F:NDatabase.Core.BTree.LazyOdbBtreePersister._oids">
            <summary>
              All loaded nodes
            </summary>
        </member>
        <member name="F:NDatabase.Core.BTree.LazyOdbBtreePersister._tree">
            <summary>
              The tree we are persisting
            </summary>
        </member>
        <member name="M:NDatabase.Core.BTree.LazyOdbBtreePersister.LoadNodeById(System.Object)">
            <summary>
              Loads a node from its id.
            </summary>
            <remarks>
              Loads a node from its id. Tries to get if from memory, if not present then loads it from odb storage
            </remarks>
            <param name="id"> The id of the nod </param>
            <returns> The node with the specific id </returns>
        </member>
        <member name="M:NDatabase.Core.BTree.LazyOdbBtreePersister.SaveNode(NDatabase.Btree.IBTreeNode)">
            <summary>
              saves the bree node Only puts the current node in an 'modified Node' map to be saved on commit
            </summary>
        </member>
        <member name="T:NDatabase.Btree.OdbBtreeMultiple">
            <summary>
              The NDatabase ODB BTree.
            </summary>
            <remarks>
              The NDatabase ODB BTree. It extends the DefaultBTree implementation to add the ODB OID generated by the ODB database.
            </remarks>
        </member>
        <member name="T:NDatabase.Btree.OdbBtreeNodeMultiple">
            <summary>
              The NDatabase ODB BTree Node implementation.
            </summary>
            <remarks>
              The NDatabase ODB BTree Node implementation. It extends the DefaultBTreeNode generic implementation to be able to be stored in the ODB database.
            </remarks>
        </member>
        <member name="F:NDatabase.Btree.OdbBtreeNodeMultiple._parent">
            <summary>
              lazy loaded
            </summary>
        </member>
        <member name="T:NDatabase.Btree.OdbBtreeNodeSingle">
            <summary>
              The NDatabase ODB BTree Node implementation.
            </summary>
            <remarks>
              The NDatabase ODB BTree Node implementation. It extends the DefaultBTreeNode generic implementation to be able to be stored in the ODB database.
            </remarks>
        </member>
        <member name="F:NDatabase.Btree.OdbBtreeNodeSingle._parent">
            <summary>
              lazy loaded
            </summary>
        </member>
        <member name="T:NDatabase.Btree.OdbBtreeSingle">
            <summary>
              The NDatabase ODB BTree.
            </summary>
            <remarks>
              The NDatabase ODB BTree. It extends the DefaultBTree implementation to add the ODB OID generated by the ODB database.
            </remarks>
        </member>
        <member name="T:NDatabase.Meta.Introspector.ClassIntrospector">
            <summary>
              The Class Introspector is used to introspect classes.
            </summary>
            <remarks>
              The Class Introspector is used to introspect classes. 
              It uses Reflection to extract class information. 
              It transforms a native Class into a ClassInfo (a meta representation of the class) 
              that contains all informations about the class.
            </remarks>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ClassIntrospector.Introspect(System.Type,System.Boolean)">
            <summary>
            </summary>
            <param name="type"> The class to introspect </param>
            <param name="recursive"> If true, goes does the hierarchy to try to analyze all classes </param>
            <returns> </returns>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ClassIntrospector.Instrospect(System.Collections.Generic.IEnumerable{NDatabase.Meta.ClassInfo})">
            <summary>
              introspect a list of classes This method return the current meta model based on the classes that currently exist in the execution classpath.
            </summary>
            <remarks>
              introspect a list of classes This method return the current meta model based on the classes that currently exist in the execution classpath. 
              The result will be used to check meta model compatibility between the meta model that is currently persisted in the database and the meta 
              model currently executing in JVM. This is used b the automatic meta model refactoring
            </remarks>
            <returns> A map where the key is the class name and the key is the ClassInfo: the class meta representation </returns>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ClassIntrospector.GetClassInfo(System.String,NDatabase.Meta.ClassInfo)">
            <summary>
              Builds a class info from a class and an existing class info 
              The existing class info is used to make sure that fields with the same name will have the same id
            </summary>
            <param name="fullClassName"> The name of the class to get info </param>
            <param name="existingClassInfo"> </param>
            <returns> A ClassInfo - a meta representation of the class </returns>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ClassIntrospector.InternalIntrospect(System.Type,System.Boolean,NDatabase.Meta.ClassInfoList)">
            <param name="type"> The class to introspect </param>
            <param name="recursive"> If true, goes does the hierarchy to try to analyze all classes </param>
            <param name="classInfoList"> map with class name that are being introspected, to avoid recursive calls </param>
        </member>
        <member name="T:NDatabase.Meta.Introspector.ObjectIntrospector">
            <summary>
              The local implementation of the Object Introspector.
            </summary>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ObjectIntrospector.GetObjectInfo(System.Object,NDatabase.Meta.ClassInfo,System.Boolean,System.Collections.Generic.IDictionary{System.Object,NDatabase.Meta.NonNativeObjectInfo},NDatabase.Meta.Introspector.IIntrospectionCallback)">
            <summary>
              retrieve object data
            </summary>
            <returns> The object info </returns>
        </member>
        <member name="M:NDatabase.Meta.Introspector.ObjectIntrospector.GetObjectInfoInternal(NDatabase.Meta.AbstractObjectInfo,System.Object,NDatabase.Meta.ClassInfo,System.Boolean,System.Collections.Generic.IDictionary{System.Object,NDatabase.Meta.NonNativeObjectInfo},NDatabase.Meta.Introspector.IIntrospectionCallback)">
            <summary>
              Build a meta representation of an object 
              <pre>warning: When an object has two fields with the same name 
                   (a private field with the same name in a parent class, the deeper field (of the parent) is ignored!)</pre>
            </summary>
            <returns> The ObjectInfo </returns>
        </member>
        <member name="T:NDatabase.Api.NonPersistentAttribute">
            <summary>
            Use when you don't want to serialize the field. 
            </summary>
            <remarks>
            In such case, mark the attribute with <code>[NonPersistent]</code>
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Engine.InstanceBuilder">
            <summary>
              Class used to build instance from Meta Object representation.
            </summary>
            <remarks>
              Class used to build instance from Meta Object representation. Layer 2 to Layer 1 conversion.
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.InstanceBuilder.BuildEnumInstance(NDatabase.Meta.EnumNativeObjectInfo,System.Type)">
            <summary>
              Builds an instance of an enum
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.InstanceBuilder.BuildArrayInstance(NDatabase.Meta.ArrayObjectInfo)">
            <summary>
              Builds an instance of an array
            </summary>
        </member>
        <member name="M:NDatabase.Meta.Compare.AttributeValueComparator.Compare(System.IComparable,System.IComparable)">
            <summary>
              The following method compares any 2 objects and test if they are equal.
              It will also compare equality of numbers in a very special way.
              Examples:
              IsEqual(Int64.MaxValue, Int64.MaxValue) //is true
              IsEqual(Int64.MaxValue, Int64.MaxValue-1) //is false
              IsEqual(123, 123.0) //is true
              IsEqual(654f, 654d) //is true
            </summary>
        </member>
        <member name="T:NDatabase.Meta.Compare.ObjectInfoComparator">
            <summary>
              Manage Object info differences.
            </summary>
            <remarks>
              Manage Object info differences. compares two object info and tells which objects in the object hierarchy has changed. This is used by the update to process to optimize it and actually update what has changed
            </remarks>
        </member>
        <member name="M:NDatabase.Meta.Compare.ObjectInfoComparator.ManageArrayChanges(NDatabase.Meta.NonNativeObjectInfo,NDatabase.Meta.NonNativeObjectInfo,System.Int32,NDatabase.Meta.ArrayObjectInfo,NDatabase.Meta.ArrayObjectInfo,System.Int32)">
            <summary>
              Checks if something in the Arary has changed, if yes, stores the change
            </summary>
            <param name="nnoi1"> The first Object meta representation (nnoi = NonNativeObjectInfo) </param>
            <param name="nnoi2"> The second object meta representation </param>
            <param name="fieldId"> The field index that this collection represents </param>
            <param name="aoi1"> The Meta representation of the array 1 (aoi = ArraybjectInfo) </param>
            <param name="aoi2"> The Meta representation of the array 2 </param>
            <param name="objectRecursionLevel"> </param>
            <returns> true if the 2 array representations are different </returns>
        </member>
        <member name="T:NDatabase.Storage.BlockStatus">
            <summary>
              To keep track of block status
            </summary>
        </member>
        <member name="T:NDatabase.Storage.BlockTypes">
            <summary>
              All Block Types of the ODB database format.
            </summary>
        </member>
        <member name="T:NDatabase.IO.MultiBufferedFileIO">
            <summary>
              Class allowing buffering for IO This class is used to give 
              a transparent access to buffered file io
            </summary>
        </member>
        <member name="F:NDatabase.IO.MultiBufferedFileIO._ioDeviceLength">
            <summary>
              The length of the io device
            </summary>
        </member>
        <member name="F:NDatabase.IO.MultiBufferedFileIO._isUsingBuffer">
            <summary>
              A boolean value to check if read write are using buffer
            </summary>
        </member>
        <member name="M:NDatabase.IO.MultiBufferedFileIO.GetOverlappingBuffers(System.Int64,System.Int32)">
            <summary>
              Check if a new buffer starting at position with a size ='size' would overlap with an existing buffer
            </summary>
            <param name="position"> </param>
            <param name="size"> </param>
            <returns> @ </returns>
        </member>
        <member name="P:NDatabase.IO.NonBufferedFileIO.CurrentPositionForDirectWrite">
            <summary>
              Current position for direct write to IO
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.INonNativeObjectWriter.InsertNonNativeObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <param name="oid"> The Oid of the object to be inserted </param>
            <param name="nnoi"> The object meta representation The object to be inserted in the database </param>
            <param name="isNewObject"> To indicate if object is new </param>
            <returns> The position of the inserted object </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.INonNativeObjectWriter.UpdateNonNativeObjectInfo(NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <summary>
              Updates an object.
            </summary>
            <remarks>
              Updates an object. <pre>Try to update in place. Only change what has changed. This is restricted to particular types (fixed size types). If in place update is
                                   not possible, then deletes the current object and creates a new at the end of the database file and updates
                                   OID object position.
                                   &#064;param object The object to be updated
                                   &#064;param forceUpdate when true, no verification is done to check if update must be done.
                                   &#064;return The oid of the object, as a negative number
                                   &#064;</pre>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.NonNativeObjectWriter.InsertNonNativeObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <param name="oid"> The Oid of the object to be inserted </param>
            <param name="nnoi"> The object meta representation The object to be inserted in the database </param>
            <param name="isNewObject"> To indicate if object is new </param>
            <returns> The position of the inserted object </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.NonNativeObjectWriter.UpdateNonNativeObjectInfo(NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <summary>
              Updates an object.
            </summary>
            <remarks>
              Updates an object. <pre>Try to update in place. Only change what has changed. This is restricted to particular types (fixed size types). If in place update is
                                   not possible, then deletes the current object and creates a new at the end of the database file and updates
                                   OID object position.
                                   &#064;param object The object to be updated
                                   &#064;param forceUpdate when true, no verification is done to check if update must be done.
                                   &#064;return The oid of the object, as a negative number
                                   &#064;</pre>
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Engine.ObjectWriter">
            <summary>
              Manage all IO writing
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.ObjectWriter._triggerManager">
            <summary>
              To manage triggers
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.CreateEmptyDatabaseHeader(System.Int64)">
            <summary>
              Creates the header of the file
            </summary>
            <param name="creationDate"> The creation date </param>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.PersistClass(NDatabase.Meta.ClassInfo,System.Int32,System.Boolean,System.Boolean)">
            <summary>
              PersistTo a single class info - This method is used by the XML Importer.
            </summary>
            <remarks>
              PersistTo a single class info - This method is used by the XML Importer.
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.WriteClassInfoHeader(NDatabase.Meta.ClassInfo,System.Int64,System.Boolean)">
            <summary>
              Write the class info header to the database file
            </summary>
            <param name="classInfo"> The class info to be written </param>
            <param name="position"> The position at which it must be written </param>
            <param name="writeInTransaction"> true if the write must be done in transaction, false to write directly </param>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.ManageIndexesForInsert(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo)">
            <summary>
              Insert the object in the index
            </summary>
            <param name="oid"> The object id </param>
            <param name="nnoi"> The object meta represenation </param>
            <returns> The number of indexes </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.ManageIndexesForDelete(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo)">
            <summary>
              Insert the object in the index
            </summary>
            <param name="oid"> The object id </param>
            <param name="nnoi"> The object meta represenation </param>
            <returns> The number of indexes </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.InsertNonNativeObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <param name="oid"> The Oid of the object to be inserted </param>
            <param name="nnoi"> The object meta representation The object to be inserted in the database </param>
            <param name="isNewObject"> To indicate if object is new </param>
            <returns> The position of the inserted object </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.UpdateNonNativeObjectInfo(NDatabase.Meta.NonNativeObjectInfo,System.Boolean)">
            <summary>
              Updates an object.
            </summary>
            <remarks>
              Updates an object. <pre>Try to update in place. Only change what has changed. This is restricted to particular types (fixed size types). If in place update is
                                   not possible, then deletes the current object and creates a new at the end of the database file and updates
                                   OID object position.
                                   &#064;param object The object to be updated
                                   &#064;param forceUpdate when true, no verification is done to check if update must be done.
                                   &#064;return The oid of the object, as a negative number
                                   &#064;</pre>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.UpdatePreviousObjectFieldOfObjectInfo(NDatabase.Api.OID,NDatabase.Api.OID,System.Boolean)">
            <summary>
              Updates the previous object position field of the object at objectPosition
            </summary>
            <param name="objectOID"> </param>
            <param name="previousObjectOID"> </param>
            <param name="writeInTransaction"> </param>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.UpdateNextObjectFieldOfObjectInfo(NDatabase.Api.OID,NDatabase.Api.OID,System.Boolean)">
            <summary>
              Update next object oid field of the object at the specific position
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.MarkAsDeleted(System.Int64,System.Boolean)">
            <summary>
              Mark a block as deleted
            </summary>
            <returns> The block size </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.WriteClassInfoBody(NDatabase.Meta.ClassInfo,System.Int64,System.Boolean)">
            <summary>
              Write the class info body to the database file.
            </summary>
            <remarks>
              Write the class info body to the database file. TODO Check if we really must recall the writeClassInfoHeader
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.WriteNativeObjectInfo(NDatabase.Meta.NativeObjectInfo,System.Int64,System.Boolean)">
            <summary>
              Actually write the object data to the database file
            </summary>
            <param name="noi"> The object meta infor The object info to be written </param>
            <param name="position"> if -1, it is a new instance, if not, it is an update </param>
            <param name="writeInTransaction"> </param>
            <returns> The object posiiton or id(if &lt; 0) </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.ManageNewObjectPointers(NDatabase.Meta.NonNativeObjectInfo,NDatabase.Meta.ClassInfo)">
            <summary>
              Updates pointers of objects, Only changes uncommitted info pointers
            </summary>
            <param name="objectInfo"> The meta representation of the object being inserted </param>
            <param name="classInfo"> The class of the object being inserted </param>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.InsertNativeObject(NDatabase.Meta.NativeObjectInfo)">
            <param name="noi"> The native object meta representation The object to be inserted in the database </param>
            <returns> The position of the inserted object </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.StoreObject(NDatabase.Api.OID,NDatabase.Meta.NonNativeObjectInfo)">
            <summary>
              Store a meta representation of an object(already as meta representation)in ODBFactory database.
            </summary>
            <remarks>
              Store a meta representation of an object(already as meta representation)in ODBFactory database. To detect if object must be updated or insert, we use the cache. To update an object, it must be first selected from the database. When an object is to be stored, if it exist in the cache, then it will be updated, else it will be inserted as a new object. If the object is null, the cache will be used to check if the meta representation is in the cache
            </remarks>
            <param name="oid"> The oid of the object to be inserted/updates </param>
            <param name="nnoi"> The meta representation of an object </param>
            <returns> The object position </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.InternalStoreObject(NDatabase.Meta.NativeObjectInfo)">
            <summary>
              Store a meta representation of a native object(already as meta representation)in ODBFactory database.
            </summary>
            <remarks>
              Store a meta representation of a native object(already as meta representation)in ODBFactory database. A Native object is an object that use native language type, String for example To detect if object must be updated or insert, we use the cache. To update an object, it must be first selected from the database. When an object is to be stored, if it exist in the cache, then it will be updated, else it will be inserted as a new object. If the object is null, the cache will be used to check if the meta representation is in the cache
            </remarks>
            <param name="noi"> The meta representation of an object </param>
            <returns> The object position @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.WriteArray(NDatabase.Meta.ArrayObjectInfo,System.Boolean)">
            <summary>
              <pre>Write an array to the database
                This is done by writing :
                - the array type : array
                - the array element type (String if it os a String [])
                - the position of the non native type, if element are non java / C# native
                - the number of element s and then the position of all elements.
                </pre>
            </summary>
            <remarks>
              <pre>Write an array to the database
                This is done by writing :
                - the array type : array
                - the array element type (String if it os a String [])
                - the position of the non native type, if element are non java / C# native
                - the number of element s and then the position of all elements.
                Example : an array with two string element : 'ola' and 'chico'
                write 22 : array
                write  20 : array of STRING
                write 0 : it is a java native object
                write 2 (as an int) : the number of elements
                write two times 0 (as long) to reserve the space for the elements positions
                then write the string 'ola', and keeps its position in the 'positions' array of long
                then write the string 'chico' and keeps its position in the 'positions' array of long
                Then write back all the positions (in this case , 2 positions) after the size of the array
                Example : an array with two User element : user1 and user2
                write 22 : array
                write  23 : array of NON NATIVE Objects
                write 251 : if 250 is the position of the user class info in database
                write 2 (as an int) : the number of elements
                write two times 0 (as long) to reserve the space for the elements positions
                then write the user user1, and keeps its position in the 'positions' array of long
                then write the user user2 and keeps its position in the 'positions' array of long
                &lt;pre&gt;
                &#064;param object
                &#064;param odbType
                &#064;param position
                &#064;param writeInTransaction
                &#064;</pre>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.InternalStoreObjectWrapper(NDatabase.Meta.AbstractObjectInfo)">
            <summary>
              This method is used to store the object : natibe or non native and return a number : - The position of the object if it is a native object - The oid (as a negative number) if it is a non native object
            </summary>
            <param name="aoi"> </param>
            <returns> </returns>
            <exception cref="T:System.Exception">System.Exception</exception>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectWriter.WriteNativeObjectHeader(System.Int32,System.Boolean,System.Byte,System.Boolean)">
            <summary>
              Write the header of a native attribute
            </summary>
        </member>
        <member name="T:NDatabase.Core.Engine.ByteArrayConverter">
            <summary>
              Converts array of bytes into native objects and native objects into array of bytes
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ByteArrayConverter.StringToByteArray(System.String,System.Int32)">
            <param name="s">Input</param>
            <param name="totalSpace"> The total space of the string (can be bigger that the real string size - to support later in place update) </param>
            <returns> The byte array that represent the string </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ByteArrayConverter.ByteArrayToString(System.Byte[])">
            <returns> The String represented by the byte array </returns>
        </member>
        <member name="T:NDatabase.Core.Engine.ObjectReader">
            <summary>
              Manage all IO Reading
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.ObjectReader._instanceBuilder">
            <summary>
              to build instances
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.ObjectReader._currentDepth">
            <summary>
              A local variable to monitor object recursion
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.ObjectReader._fsi">
            <summary>
              The fsi is the object that knows how to write and read native types
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.#ctor(NDatabase.Core.IStorageEngine)">
            <summary>
              The constructor
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadObjectInfoHeaderFromOid(NDatabase.Api.OID,System.Boolean)">
            <summary>
              Reads the pointers(ids or positions) of an object that has the specific oid
            </summary>
            <param name="oid"> The oid of the object we want to read the pointers </param>
            <param name="useCache"> </param>
            <returns> The ObjectInfoHeader @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadNonNativeObjectInfoFromPosition(NDatabase.Meta.ClassInfo,NDatabase.Api.OID,System.Int64,System.Boolean,System.Boolean)">
            <summary>
              Reads a non non native Object Info (Layer2) from its position
            </summary>
            <param name="classInfo"> </param>
            <param name="oid"> can be null </param>
            <param name="position"> </param>
            <param name="useCache"> </param>
            <param name="returnInstance"> </param>
            <returns> The meta representation of the object @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadAtomicNativeObjectInfo(System.Int32)">
            <summary>
              Reads an atomic object
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.GetNextObjectOID(NDatabase.Api.OID)">
            <summary>
              Gets the next object oid of the object with the specific oid
            </summary>
            <returns> The position of the next object. If there is no next object, return -1 @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.GetObjectPositionFromItsOid(NDatabase.Api.OID,System.Boolean,System.Boolean)">
            <summary>
              Gets the real object position from its OID
            </summary>
            <param name="oid"> The oid of the object to get the position </param>
            <param name="useCache"> </param>
            <param name="throwException"> To indicate if an exception must be thrown if object is not found </param>
            <returns> The object position, if object has been marked as deleted then return StorageEngineConstant.DELETED_OBJECT_POSITION @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.GetAllIds(System.Byte)">
            <summary>
              Returns information about all OIDs of the database
            </summary>
            <param name="idType"> </param>
            <returns> @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadClassInfoBody(NDatabase.Meta.ClassInfo)">
            <summary>
              Reads the body of a class info
            </summary>
            <param name="classInfo"> The class info to be read with already read header </param>
            <returns> The read class info @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadClassAttributeInfo">
            <summary>
              Read an attribute of a class at the current position
            </summary>
            <returns> The ClassAttributeInfo description of the class attribute @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadNonNativeObjectAtPosition(System.Int64,System.Boolean,System.Boolean)">
            <summary>
              Reads an object at the specific position
            </summary>
            <param name="position"> The position to read </param>
            <param name="useCache"> To indicate if cache must be used </param>
            <param name="returnInstance"> indicate if an instance must be return of just the meta info </param>
            <returns> The object with position @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadObjectInfoFromPosition(NDatabase.Meta.ClassInfo,System.Int64,System.Boolean,System.Boolean)">
            <summary>
              Reads an object info(Object meta information like its type and its values) from the database file <p /> <pre>reads its type and then read all its attributes.</pre>
            </summary>
            <remarks>
              Reads an object info(Object meta information like its type and its values) from the database file <p /> <pre>reads its type and then read all its attributes.
                                                                                                                        If one attribute is a non native object, it will be read (recursivly).
                                                                                                                        &lt;p/&gt;</pre>
            </remarks>
            <param name="classInfo"> If null, we are probably reading a native instance : String for example </param>
            <param name="objectPosition"> </param>
            <param name="useCache"> To indicate if cache must be used. If not, the old version of the object will read </param>
            <param name="returnObjects"> </param>
            <returns> The object abstract meta representation @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadObjectInfoValuesFromPosition(NDatabase.Meta.ClassInfo,NDatabase.Api.OID,System.Int64,System.Boolean,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Int32)">
            <param name="classInfo"> The class info of the objects to be returned </param>
            <param name="oid"> The Object id of the object to return data </param>
            <param name="position"> The position of the object to read </param>
            <param name="useCache"> To indicate if cache must be used </param>
            <param name="attributeNames"> The list of the attribute name for which we need to return a value, an attributename can contain relation like profile.name </param>
            <param name="relationAttributeNames"> The original names of attributes to read the values, an attributename can contain relation like profile.name </param>
            <param name="recursionLevel"> The recursion level of this call </param>
            <returns> A Map where keys are attributes names and values are the values of there attributes @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadNativeAttributeHeader">
            <summary>
              Read the header of a native attribute <pre>The header contains
                                                      - The block size = int
                                                      - The block type = byte
                                                      - The OdbType ID = int
                                                      - A boolean to indicate if object is nulls.</pre>
            </summary>
            <remarks>
              Read the header of a native attribute <pre>The header contains
                                                      - The block size = int
                                                      - The block type = byte
                                                      - The OdbType ID = int
                                                      - A boolean to indicate if object is nulls.
                                                      This method reads all the bytes and then convert the byte array to the values</pre>
            </remarks>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadNativeObjectInfo(System.Int32,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Reads a meta representation of a native object
            </summary>
            <param name="odbDeclaredTypeId"> The type of attribute declared in the ClassInfo. May be different from actual attribute type in caso of OID and OdbObjectId </param>
            <param name="position"> </param>
            <param name="useCache"> </param>
            <param name="returnObject"> </param>
            <param name="readHeader"> </param>
            <returns> The native object representation @ </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadEnumObjectInfo">
            <summary>
              Reads an enum object
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.ObjectReader.ReadArray(System.Int64,System.Boolean,System.Boolean)">
            <summary>
              Reads an array from the database file
            </summary>
            <returns> The Collection or the array @ </returns>
        </member>
        <member name="T:NDatabase.Meta.StorageEngineConstant">
            <summary>
              Some Storage engine constants about offset position for object writing/reading.
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.MaxNumberOfWriteObjectPerTransaction">
            <summary>
            Default max number of write object actions per transaction - 10 000
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.IdBlockSize">
            <summary>
              header(34) + 1000 * 18
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.FieldDoesNotExist">
            <summary>
              this occurs when a class has been refactored adding a field.
            </summary>
            <remarks>
              this occurs when a class has been refactored adding a field. Old objects do not the new field
            </remarks>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.BlockIdRepetitionIdType">
            <summary>
              pull id type (byte),id(long),
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderVersionPosition">
            <summary>
              File format version : 1 int (4 bytes)
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.NullObjectId">
            <summary>
              Used to make an attribute reference a null object - setting its id to zero
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderDatabaseIdPosition">
            <summary>
              The Database ID : 4 Long (4*8 bytes)
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderLastTransactionId">
            <summary>
              The last Transaction ID 2 long (2*4*8 bytes)
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderNumberOfClassesPosition">
            <summary>
              The number of classes in the meta model 1 long (4*8 bytes)
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderFirstClassOid">
            <summary>
              The first class OID : 1 Long (8 bytes)
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderLastCloseStatusPosition">
            <summary>
              The last ODB close status.
            </summary>
            <remarks>
              The last ODB close status. Used to detect if the transaction is ok : 1 byte
            </remarks>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderDatabaseCharacterEncodingPosition">
            <summary>
              The Database character encoding : 50 bytes
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderCurrentIdBlockPosition">
            <summary>
              The position of the current id block: 1 long
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.DatabaseHeaderFirstIdBlockPosition">
            <summary>
              First ID Block position
            </summary>
        </member>
        <member name="F:NDatabase.Meta.StorageEngineConstant.BlockIdOffsetForBlockStatus">
            <summary>
              <pre>ID Block Header :
                Block size             : 1 int
                Block type             : 1 byte
                Block status           : 1 byte
                Prev block position    : 1 long
                Next block position    : 1 long
                Block number           : 1 int
                Max id                 : 1 long
                Total size = 34</pre>
            </summary>
        </member>
        <member name="T:NDatabase.Core.Engine.IdManager">
            <summary>
              Class to manage the ids of all the objects of the database.
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.IdManager._lastIds">
            <summary>
              Contains the last ids: id value,id position, id value, id position=&gt; the array is created with twice the size
            </summary>
        </member>
        <member name="M:NDatabase.Core.Engine.IdManager.#ctor(NDatabase.Core.IObjectWriter,NDatabase.Core.IObjectReader,NDatabase.Storage.CurrentIdBlockInfo)">
            <param name="objectWriter"> The object writer </param>
            <param name="objectReader"> The object reader </param>
            <param name="currentIdBlock">Current Id block data </param>
        </member>
        <member name="M:NDatabase.Core.Engine.IdManager.MustShift">
            <summary>
              To check if the id block must shift: that a new id block must be created
            </summary>
            <returns> a boolean value to check if block of id is full </returns>
        </member>
        <member name="M:NDatabase.Core.Engine.IdManager.GetNextId(System.Int64,System.Byte,System.Byte)">
            <summary>
              Gets an id for an object (instance)
            </summary>
            <param name="objectPosition"> the object position (instance) </param>
            <param name="idType"> The type id : object,class, unknown </param>
            <param name="idStatus"> </param>
            <returns> The id </returns>
        </member>
        <member name="T:NDatabase.Oid.BaseOID">
            <summary>
              The abstract class to represent OID.
            </summary>
            <remarks>
              The abstract class to represent OID. 
              OID is a unique identifier for NDatabase ODB entities like objects and classes. 
              The id is generated by NDatabase
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Query.Criteria.QueryResultAction`1">
            <summary>
              Class that manage normal query.
            </summary>
            <remarks>
              Class that manage normal query. Query that return a list of objects. For each object That matches the query criteria, the objectMatch method is called and it keeps the objects in the 'objects' instance.
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.QueryResultAction`1._instanceBuilder">
            <summary>
              An object to build instances
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Criteria.CriteriaQueryExecutionPlan">
            <summary>
              A simple Criteria execution plan Check if the query can use index and tries to find the best index to be used
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.CriteriaQueryExecutionPlan._details">
            <summary>
              To keep the execution detail
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.CriteriaQueryExecutionPlan._end">
            <summary>
              to keep track of the end date time of the plan
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Criteria.CriteriaQueryExecutionPlan._start">
            <summary>
              to keep track of the start date time of the plan
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.Criteria.CriteriaQueryExecutionPlan.GetAllInvolvedFieldIds(System.Collections.Generic.IList{System.String})">
            <summary>
              Transform a list of field names into a list of field ids
            </summary>
            <param name="fields"> </param>
            <returns> The array of field ids </returns>
        </member>
        <member name="T:NDatabase.Core.Query.List.AbstractBTreeCollection`1">
            <summary>
              A collection that uses a BTree as an underlying system to provide ordered by Collections <p></p>
            </summary>
        </member>
        <member name="T:NDatabase.Api.IObjectSet`1">
            <summary>
            query resultset.
            
            The <code>ObjectSet</code> interface serves as a cursor to
            iterate through a set of objects retrieved by a query.
            </summary>
        </member>
        <member name="M:NDatabase.Api.IObjectSet`1.HasNext">
            <summary>
            returns <code>true</code> if the <code>ObjectSet</code> has more elements.
            </summary>
            <returns><code>true</code> if the <code>ObjectSet</code> has more elements</returns>
        </member>
        <member name="M:NDatabase.Api.IObjectSet`1.Next">
            <summary>
            returns the next object in the <code>ObjectSet</code>.
            </summary>
            <returns>the next object in the <code>ObjectSet</code>.</returns>C
        </member>
        <member name="M:NDatabase.Api.IObjectSet`1.GetFirst">
            <summary>
              Return the first object of the collection, if exist
            </summary>
            <returns> </returns>
        </member>
        <member name="M:NDatabase.Api.IObjectSet`1.Reset">
            <summary>
            resets the <code>ObjectSet</code> cursor before the first element. 
            
            A subsequent call to <code>next()</code> will return the first element.
            </summary>
        </member>
        <member name="M:NDatabase.Core.IInternalObjectSet`1.AddWithKey(NDatabase.Api.IOdbComparable,`0)">
            <summary>
              Add an object into the collection using a specific ordering key
            </summary>
            <param name="key"> </param>
            <param name="item"> The object can be an OID, can o NNOI (NonNativeObjectInfo) or the object </param>
        </member>
        <member name="M:NDatabase.Core.Query.List.AbstractBTreeCollection`1.AddWithKey(NDatabase.Api.IOdbComparable,`0)">
            <summary>
              Adds the object in the btree with the specific key
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.List.InMemoryBTreeCollection`1">
            <summary>
              An implementation of an ordered Collection based on a BTree implementation that holds all objects in memory
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.List.LazyBTreeCollection`1">
            <summary>
              A collection using a BTtree as a back-end component.
            </summary>
            <remarks>
              A collection using a BTtree as a back-end component. Lazy because it only keeps the oids of the objects. When asked for an object, loads it on demand and returns it
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Query.List.LazySimpleListFromOid`1">
            <summary>
              A simple list to hold query result.
            </summary>
            <remarks>
              A simple list to hold query result. It is used when no index and no order by is used and inMemory = false This collection does not store the objects, it only holds the OIDs of the objects. When user ask an object the object is lazy loaded by the getObjectFromId method
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListFromOid`1._engine">
            <summary>
              The odb engine to lazily get objects
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListFromOid`1._returnInstance">
            <summary>
              indicate if objects must be returned as instance (true) or as non native objects (false)
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListFromOid`1._currentPosition">
            <summary>
              a cursor when getting objects
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.List.LazySimpleListOfAoi`1">
            <summary>
              A simple list to hold query result.
            </summary>
            <remarks>
              A simple list to hold query result. It is used when no index and no order by This collection does not store the objects, it only holds the Abstract Object Info (AOI) of the objects. When user ask an object the object is lazy loaded by the buildInstance method
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListOfAoi`1._instanceBuilder">
            <summary>
              The odb engine to lazily get objects
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListOfAoi`1._returnInstance">
            <summary>
              indicate if objects must be returned as instance (true) or as non native objects (false)
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.List.LazySimpleListOfAoi`1._currentPosition">
            <summary>
              a cursor when getting objects
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.List.SimpleList`1">
            <summary>
              A simple list to hold query result.
            </summary>
            <remarks>
              A simple list to hold query result. It is used when no index and no order by is used and inMemory = true
            </remarks>
        </member>
        <member name="T:NDatabase.Api.IObjectValues">
            <summary>
              Interface that will be implemented to hold a row of a result of an Object Values Query
            </summary>
        </member>
        <member name="M:NDatabase.Api.IObjectValues.GetByAlias(System.String)">
            <summary>
            Get result by alias
            </summary>
            <param name="alias">Alias for result</param>
            <returns>Object result</returns>
        </member>
        <member name="M:NDatabase.Api.IObjectValues.GetByIndex(System.Int32)">
            <summary>
            Get result by index
            </summary>
            <param name="index">Index for result</param>
            <returns>Object result</returns>
        </member>
        <member name="M:NDatabase.Api.IObjectValues.GetValues">
            <summary>
            Get values result
            </summary>
            <returns>Array of objects as values</returns>
        </member>
        <member name="F:NDatabase.Core.Query.List.ObjectValues._valuesByAlias">
            <summary>
              key=alias,value=value
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.List.InMemoryBTreeCollectionForValues">
            <summary>
              An ordered Collection to hold values (not objects) based on a BTree implementation.
            </summary>
            <remarks>
              An ordered Collection to hold values (not objects) based on a BTree implementation. It holds all values in memory.
            </remarks>
        </member>
        <member name="T:NDatabase.Api.IValues">
            <summary>
              The main interface of all Object Values query results of NDatabase ODB
            </summary>
        </member>
        <member name="M:NDatabase.Api.IValues.NextValues">
            <summary>
            Get next values set
            </summary>
            <returns>Next values</returns>
        </member>
        <member name="T:NDatabase.Core.Query.List.SimpleListForValues">
            <summary>
              A simple list to hold query result for Object Values API.
            </summary>
            <remarks>
              A simple list to hold query result for Object Values API. It is used when no index and no order by is used and inMemory = true
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Query.Values.AverageValueAction">
            <summary>
              An action to compute the average value of a field
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Values.CountAction">
            <summary>
              An action to count objects of a query
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Values.FieldValueAction">
            <summary>
              An action to retrieve an object field
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Values.FieldValueAction._value">
            <summary>
              The value of the attribute
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Values.GroupByValuesQueryResultAction._groupByResult">
            <summary>
              When executing a group by result, results are temporary stored in a hash map and at the end transfered to a Values objects In this case, the key of the map is the group by composed key, the value is a ValuesQueryResultAction
            </summary>
        </member>
        <member name="F:NDatabase.Core.Query.Values.GroupByValuesQueryResultAction._instanceBuilder">
            <summary>
              An object to build instances
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Values.MaxValueAction">
            <summary>
              An action to compute the max value of a field
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Values.MinValueAction">
            <summary>
              An action to compute the max value of a field
            </summary>
        </member>
        <member name="T:NDatabase.Core.Query.Values.SizeAction">
            <summary>
              An action to retrieve a size of a list.
            </summary>
            <remarks>
              An action to retrieve a size of a list. It is used by the Object Values API. When calling odb.getValues(new ValuesCriteriaQuery(Handler.class, Where .equal("id", id)).size("parameters"); The sublist action will return Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. if parameters list contains [param1,param2,param3,param4], sublist("parameters",1,2) will return a sublist containing [param2,param3]
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Query.Values.SublistAction">
            <summary>
              An action to retrieve a sublist of list.
            </summary>
            <remarks>
              An action to retrieve a sublist of list. It is used by the Object Values API. When calling odb.getValues(new ValuesCriteriaQuery(Handler.class, Where .equal("id", id)).sublist("parameters",fromIndex, size); The sublist action will return Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. if parameters list contains [param1,param2,param3,param4], sublist("parameters",1,2) will return a sublist containing [param2,param3]
            </remarks>
        </member>
        <member name="T:NDatabase.Core.Query.Values.ValuesCriteriaQuery">
            <summary>
              A values Criteria query is a query to retrieve object values instead of objects.
            </summary>
            <remarks>
              A values Criteria query is a query to retrieve object values instead of objects. 
              Values Criteria Query allows one to retrieve one field value of an object: 
               - A field values 
               - The sum of a specific numeric field 
               - The Max value of a specific numeric field 
               - The Min value of a specific numeric field 
               - The Average value of a specific numeric value
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.Values.ValuesCriteriaQuery._returnInstance">
            <summary>
              To specify if the result must build instance of object meta representation
            </summary>
        </member>
        <member name="M:NDatabase.Core.Query.Values.ValuesCriteriaQuery.GetAllInvolvedFields">
            <summary>
              Returns the list of involved fields for this query.
            </summary>
            <remarks>
              Returns the list of involved fields for this query. List of String <pre>If query must return sum("value") and field("name"), involvedField will contain "value","name"</pre>
            </remarks>
        </member>
        <member name="F:NDatabase.Core.Query.Values.ValuesQueryResultAction._queryFieldActions">
            <summary>
              A copy of the query object actions
            </summary>
        </member>
        <member name="T:NDatabase.Api.IObjectRepresentation">
            <summary>
              used to give the user an instance of an object representation, level2.
            </summary>
            <remarks>
              used to give the user an instance of an object representation, level2. 
              The Object Representation encapsulates the NonNativeObjectInfo which is the internal object representation.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.IObjectRepresentation.GetOid">
            <summary>
              Retrieves the oid of the object
            </summary>
        </member>
        <member name="M:NDatabase.Api.IObjectRepresentation.GetObjectClassName">
            <summary>
              Retrieves the full object class name
            </summary>
        </member>
        <member name="M:NDatabase.Api.IObjectRepresentation.GetValueOf(System.String)">
            <summary>
              Return the value of a specific attribute
            </summary>
        </member>
        <member name="M:NDatabase.Api.IObjectRepresentation.SetValueOf(System.String,System.Object)">
            <summary>
              Sets the value of a specific attribute
            </summary>
        </member>
        <member name="T:NDatabase.Cache.OdbCache">
            <summary>
              A cache of objects.
            </summary>
        </member>
        <member name="F:NDatabase.Cache.OdbCache._objectInfoHeadersCacheFromOid">
            <summary>
              Entry to get object info pointers (position,next object pos, previous object pos and class info pos) from the id
            </summary>
        </member>
        <member name="F:NDatabase.Cache.OdbCache._objectPositionsByIds">
            <summary>
              <pre>To resolve the update of an id object position:
                When an object is full updated(the current object is being deleted and a new one os being created),
                the id remain the same but its position change.</pre>
            </summary>
            <remarks>
              <pre>To resolve the update of an id object position:
                When an object is full updated(the current object is being deleted and a new one os being created),
                the id remain the same but its position change.
                But the update is done in transaction, so it is not flushed until the commit happens
                So after the update when i need the position to make the old object a pointer, i have no way to get
                the right position. To resolve this, i keep a cache of ids where i keep the non commited value</pre>
            </remarks>
        </member>
        <member name="F:NDatabase.Cache.OdbCache._objects">
            <summary>
              object cache - used to know if object exist in the cache TODO use hashcode instead?
            </summary>
        </member>
        <member name="F:NDatabase.Cache.OdbCache._oids">
            <summary>
              Entry to get an object from its oid
            </summary>
        </member>
        <member name="F:NDatabase.Cache.OdbCache._unconnectedZoneOids">
            <summary>
              To keep track of the oid that have been created or modified in the current transaction
            </summary>
        </member>
        <member name="M:NDatabase.Cache.OdbCache.AddObjectInfoOfNonCommitedObject(NDatabase.Meta.ObjectInfoHeader)">
            <summary>
              Only adds the Object info - used for non committed objects
            </summary>
        </member>
        <member name="M:NDatabase.Cache.OdbCache.GetObjectPositionByOid(NDatabase.Api.OID)">
            <summary>
              Returns the position or -1 if it is not is the cache or StorageEngineConstant.NULL_OBJECT_ID_ID if it has been marked as deleted
            </summary>
        </member>
        <member name="F:NDatabase.Cache.OdbCache.Cache`1.InsertingObjects">
            <summary>
              To resolve cyclic reference, keep track of objects being inserted
            </summary>
        </member>
        <member name="T:NDatabase.Transaction.OdbTransaction">
            <summary>
            The transaction class is used to guarantee ACID behavior.
            </summary>
            <remarks>
            The transaction class is used to guarantee ACID behavior. It keep tracks of all session
            operations. It uses the WriteAction class to store all changes that can not be written to the file
            before the commit.
            The transaction is held by The Session class and manage commits and rollbacks.
            All WriteActions are written in a transaction file to be sure to be able to commit and in case
            of very big transaction where all WriteActions can not be stored in memory.
            </remarks>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._creationDateTime">
            <summary>
              The transaction creation time
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._currentWriteAction">
            <summary>
              The same write action is reused for successive writes
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._currentWritePositionInWa">
            <summary>
              The position of the next write for WriteAction
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._fsi">
            <summary>
              A file interface to the transaction file - used to read/write the file
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._fsiToApplyWriteActions">
            <summary>
              A file interface to the engine main file
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._hasAllWriteActionsInMemory">
            <summary>
              To indicate if all write actions are in memory - if not, transaction must read them from transaction file o commit the transaction
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._hasBeenPersisted">
            <summary>
              To indicate if transaction has already been persisted in file
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._isCommited">
            <summary>
              To indicate if transaction was confirmed = committed
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._numberOfWriteActions">
            <summary>
              The number of write actions
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._session">
            <summary>
              The transaction session
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._wasRollbacked">
            <summary>
              To indicate if transaction was rollbacked
            </summary>
        </member>
        <member name="F:NDatabase.Transaction.OdbTransaction._writeActions">
            <summary>
              All the pending writing that must be applied to actually commit the transaction
            </summary>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.Reset">
            <summary>
              Reset the transaction
            </summary>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.GetNumberOfWriteActions">
            <returns> Returns the numberOfWriteActions. </returns>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.SetWritePosition(System.Int64)">
            <summary>
              Set the write position (position in main database file).
            </summary>
            <remarks>
              Set the write position (position in main database file). This is used to know if the next write can be appended to the previous one (in the same current Write Action) or not.
            </remarks>
            <param name="position"> </param>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.AddWriteAction(NDatabase.Transaction.WriteAction,System.Boolean)">
            <summary>
              Adds a write action to the transaction
            </summary>
            <param name="writeAction"> The write action to be added </param>
            <param name="persistWriteAction"> To indicate if write action must be persisted </param>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.SetCommited">
            <summary>
              Mark te transaction file as committed
            </summary>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.CommitMetaModel">
            <summary>
              Used to commit meta model : classes This is useful when running in client server mode TODO Check this
            </summary>
        </member>
        <member name="M:NDatabase.Transaction.OdbTransaction.BuildClassInfoForCommit(NDatabase.Meta.ClassInfo)">
            <summary>
              Shift all unconnected infos to connected (committed) infos
            </summary>
            <param name="classInfo"> </param>
            <returns> The updated class info </returns>
        </member>
        <member name="T:NDatabase.Transaction.WriteAction">
            <summary>
              The WriteAction class is the description of a Write operation that will be applied to the main database file when committing.
            </summary>
            <remarks>
              The WriteAction class is the description of a Write operation that will be applied to the main database file when committing.
              All operations(writes) that can not be written to the database file before committing, 
              pointers (for example) are stored in WriteAction objects. The transaction keeps track of all these WriteActions. 
              When committing, the transaction apply each WriteAction to the engine database file.
            </remarks>
        </member>
        <member name="T:NDatabase.Transaction.LocalSession">
            <summary>
              The session object used when ODB is used in local/embedded mode
            </summary>
        </member>
        <member name="T:NDatabase.Transaction.Session">
            <summary>
              An ODB Session.
            </summary>
            <remarks>
              An ODB Session. Keeps track of all the session operations. 
              Caches objects and manage the transaction. The meta model of the database is stored in the session.
            </remarks>
        </member>
        <member name="F:NDatabase.Transaction.Session._readObjectsCache">
            <summary>
              A temporary cache used for object info read
            </summary>
        </member>
        <member name="T:NDatabase.Cache.ReadObjectsCache">
            <summary>
              A temporary cache of objects.
            </summary>
        </member>
        <member name="F:NDatabase.Cache.ReadObjectsCache._readingObjectInfo">
            <summary>
              To resolve cyclic reference, keep track of objects being read
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.InternalTriggerManager._listOfDeleteTriggers">
            <summary>
                key is class Name, value is the collection of triggers for the class
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.InternalTriggerManager._listOfInsertTriggers">
            <summary>
                key is class Name, value is the collection of triggers for the class
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.InternalTriggerManager._listOfSelectTriggers">
            <summary>
                key is class Name, value is the collection of triggers for the class
            </summary>
        </member>
        <member name="F:NDatabase.Core.Engine.InternalTriggerManager._listOfUpdateTriggers">
            <summary>
                key is class Name, value is the collection of triggers for the class
            </summary>
        </member>
        <member name="T:NDatabase.Api.Triggers.ITriggerManager">
            <summary>
            Triggers manager
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.ITriggerManager.AddUpdateTrigger(NDatabase.Api.Triggers.UpdateTrigger)">
            <summary>
              Used to add an update trigger callback for the specific class
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.ITriggerManager.AddInsertTrigger(NDatabase.Api.Triggers.InsertTrigger)">
            <summary>
              Used to add an insert trigger callback for the specific class
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.ITriggerManager.AddDeleteTrigger(NDatabase.Api.Triggers.DeleteTrigger)">
            <summary>
              USed to add a delete trigger callback for the specific class
            </summary>
        </member>
        <member name="M:NDatabase.Api.Triggers.ITriggerManager.AddSelectTrigger(NDatabase.Api.Triggers.SelectTrigger)">
            <summary>
              Used to add a select trigger callback for the specific class
            </summary>
        </member>
        <member name="M:NDatabase.Core.BTree.IndexManager.RebuildIndex(System.String)">
            <summary>
              Used to rebuild an index
            </summary>
        </member>
        <member name="T:NDatabase.Odb">
            <summary>
              A basic adapter for ODB interface
            </summary>
        </member>
        <member name="T:NDatabase.Api.IOdb">
            <summary>
            Database engine interface. 
            </summary>
            <remarks>
            The interface provides all methods to store, retrieve and delete objects and to change object state.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.IOdb.Store``1(``0)">
            <summary>
            Stores the specified plain object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>Object ID of stored plain object.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.Delete``1(``0)">
            <summary>
            Deletes the specified plain object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>Object ID of deleted plain object.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.DeleteObjectWithId(NDatabase.Api.OID)">
            <summary>
            Deletes the object with Object ID.
            </summary>
            <param name="oid">The oid of the object to be deleted.</param>
        </member>
        <member name="M:NDatabase.Api.IOdb.GetObjectId``1(``0)">
            <summary>
            Gets the object id of an database-aware object.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
            <returns>The database internal Object ID.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.GetObjectFromId(NDatabase.Api.OID)">
            <summary>
            Gets the object from Object ID.
            </summary>
            <param name="id">The Object ID.</param>
            <returns>The object with the specified Object ID.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.Ext">
            <summary>
            Get the extension of database interface to get the access to advanced functions
            </summary>
            <returns>Extended interface to database.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.IsClosed">
            <summary>
            Determines whether the database is closed.
            </summary>
            <returns>
              <c>true</c> if the database is closed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.QueryAndExecute``1">
            <summary>
            Queries the database for instances of specified type and execute the query.
            </summary>
            <remarks>
            Shortcut for <code>Query&lt;T&gt;().Execute&lt;T&gt;()</code>
            </remarks>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>List of stored objects that matches the query.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.Query``1">
            <summary>
            Factory method to create a new instance of the query.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>New instance of query for the specified object type.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.ValuesQuery``1">
            <summary>
            Factory method to create a new instance of the values query.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>New instance of values query for the specified object type.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.ValuesQuery``1(NDatabase.Api.OID)">
            <summary>
            Factory method to create a new instance of the values query for specified oid.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="oid">The oid of the stored plain object.</param>
            <returns>New instance of values query for the specified object with a given oid.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.AsQueryable``1">
            <summary>
            As the queryable.
            </summary>
            <remarks>
            Interface for LINQ to NDatabase
            </remarks>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>Queryable collection</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.Commit">
            <summary>
            Commits all changes of the database.
            </summary>
        </member>
        <member name="M:NDatabase.Api.IOdb.Rollback">
            <summary>
            Rollbacks all uncommitted changes of the database.
            </summary>
        </member>
        <member name="M:NDatabase.Api.IOdb.Close">
            <summary>
              Closes the database.
            </summary>
            <remarks>
              Automatically commit uncommitted changes of the database.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.IOdb.DefragmentTo(System.String)">
            <summary>
            Defragments database to specified location.
            </summary>
            <param name="newFileName">New name of the file.</param>
        </member>
        <member name="M:NDatabase.Api.IOdb.IndexManagerFor``1">
            <summary>
            Get the indexes manager for specified object type.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>Index manager.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.TriggerManagerFor``1">
            <summary>
            Get the triggers manager for specified object type.
            </summary>
            <typeparam name="T">Plain object type.</typeparam>
            <returns>Trigger manager.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.GetRefactorManager">
            <summary>
            Gets the refactor manager.
            </summary>
            <remarks>
            Refactor manager allows on updating database schema, when classes definition were changed.
            </remarks>
            <returns>Refactor manager.</returns>
        </member>
        <member name="M:NDatabase.Api.IOdb.Disconnect``1(``0)">
            <summary>
            Disconnects the specified plain object from the current session.
            </summary>
            <remarks>
            The object is removed from the cache.
            </remarks>
            <typeparam name="T">Plain object type.</typeparam>
            <param name="plainObject">The plain object.</param>
        </member>
        <member name="M:NDatabase.Odb.#ctor(System.String)">
            <summary>
              protected Constructor
            </summary>
        </member>
        <member name="M:NDatabase.Odb.DeleteObjectWithId(NDatabase.Api.OID)">
            <summary>
              Delete an object from the database with the id
            </summary>
            <param name="oid"> The object id to be deleted </param>
        </member>
        <member name="T:NDatabase.Api.IOdbExt">
            <summary>
              An interface to provider extended access to ODB.
            </summary>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetObjectExternalOID``1(``0)">
            <summary>
              Gets the external OID of an Object.
            </summary>
            <remarks>
              Gets the external OID of an Object. 
              The external OID contains the ID of the database + the oid of the object. 
              The External OID can be used to identify objects outside the ODB database 
              as it should be unique across databases. It can be used for example 
              to implement a replication process.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetDatabaseId">
            <summary>
              Get the Database ID
            </summary>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.ConvertToExternalOID(NDatabase.Api.OID)">
            <summary>
              Convert an OID to External OID
            </summary>
            <returns> The external OID </returns>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetObjectVersion(NDatabase.Api.OID)">
            <summary>
              Returns the object version of the object that has the specified OID
            </summary>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetObjectCreationDate(NDatabase.Api.OID)">
            <summary>
              Returns the object creation date in ms since 1/1/1970
            </summary>
            <returns> The creation date </returns>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetObjectUpdateDate(NDatabase.Api.OID)">
            <summary>
              Returns the object last update date in ms since 1/1/1970
            </summary>
            <returns> The last update date </returns>
        </member>
        <member name="M:NDatabase.Api.IOdbExt.GetDbId">
            <summary>
              Return the name of the database
            </summary>
            <returns> the file name </returns>
        </member>
        <member name="T:NDatabase.Api.OdbConfiguration">
            <summary>
              The main NDatabase ODB Configuration class.
            </summary>
            <remarks>
              All engine configuration is done via this class.
            </remarks>
        </member>
        <member name="F:NDatabase.Api.OdbConfiguration.DefaultIndexBTreeDegree">
            <summary>
            Default index BTree degree - 20
            </summary>
        </member>
        <member name="F:NDatabase.Api.OdbConfiguration._indexBTreeDegree">
            <summary>
              The default btree size for index btrees
            </summary>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.EnableBTreeValidation">
            <summary>
            Enables the B tree validation.
            </summary>
            <remarks>
            It is more safe to run with that (finding issues), but that hits performance.
            </remarks>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.IsBTreeValidationEnabled">
            <summary>
            Determines whether [is B tree validation enabled].
            </summary>
            <returns>
              <c>true</c> if [is B tree validation enabled]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.DisableBTreeValidation">
            <summary>
            Disables the B tree validation.
            </summary>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.GetIndexBTreeDegree">
            <summary>
            Get index BTree degree (on start it is equals to 20)
            </summary>
            <remarks>
            It is less safe to run without that (finding issues), but that improves performance.
            </remarks>
            <returns>Degree of index BTree</returns>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.SetIndexBTreeDegree(System.Int32)">
            <summary>
            Sets the index B tree degree.
            </summary>
            <remarks>
            Default value is equal to 20.
            </remarks>
            <param name="indexBTreeSize">Size of the index B tree.</param>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.IsLoggingEnabled">
            <summary>
            Determines whether [is logging enabled].
            </summary>
            <returns>
              <c>true</c> if [is logging enabled]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.EnableLogging">
            <summary>
            Enables the logging.
            </summary>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.DisableLogging">
            <summary>
            Disables the logging.
            </summary>
        </member>
        <member name="M:NDatabase.Api.OdbConfiguration.RegisterLogger(NDatabase.ILogger)">
            <summary>
            Registers the logger.
            </summary>
            <remarks>
            Automatically enables the logging.
            </remarks>
            <param name="logger">The logger.</param>
        </member>
        <member name="T:NDatabase.OdbFactory">
            <summary>
            The NDatabase Factory to open new instance of local odb.
            </summary>
        </member>
        <member name="M:NDatabase.OdbFactory.Open(System.String)">
            <summary>
            Opens the database instance with the specified file name.
            </summary>
            <param name="fileName">Name of the file.</param>
            <returns>IOdb.</returns>
        </member>
        <member name="M:NDatabase.OdbFactory.OpenLast">
            <summary>
            Opens the database instance with the last given name.
            </summary>
            <returns>IOdb.</returns>
        </member>
        <member name="M:NDatabase.OdbFactory.OpenInMemory">
            <summary>
            Opens a database in the In-Memory mode.
            </summary>
            <returns>IOdb implementation.</returns>
        </member>
        <member name="M:NDatabase.OdbFactory.Delete(System.String)">
            <summary>
            Deletes the specified file name.
            </summary>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="T:NDatabase.Tool.DLogger">
            <summary>
              Simple logging class
            </summary>
        </member>
        <member name="T:NDatabase.ILogger">
            <summary>
            Base interface for creacting custom logger
            </summary>
        </member>
        <member name="M:NDatabase.ILogger.Warning(System.String)">
            <summary>
            Log message with warn level
            </summary>
            <param name="message">Mssage to log</param>
        </member>
        <member name="M:NDatabase.ILogger.Debug(System.String)">
            <summary>
            Log message with debug level
            </summary>
            <param name="message">Mssage to log</param>
        </member>
        <member name="M:NDatabase.ILogger.Info(System.String)">
            <summary>
            Log message with info level
            </summary>
            <param name="message">Mssage to log</param>
        </member>
        <member name="M:NDatabase.ILogger.Error(System.String)">
            <summary>
            Log message with error level
            </summary>
            <param name="message">Mssage to log</param>
        </member>
        <member name="F:NDatabase.IO.MultiBuffer.NumberOfBuffers">
            <summary>
              The number of buffers.
            </summary>
        </member>
        <member name="F:NDatabase.IO.MultiBuffer._bufferSize">
            <summary>
              The buffer size.
            </summary>
        </member>
        <member name="F:NDatabase.IO.MultiBuffer._bufferHasBeenUsedForWrite">
            <summary>
              To know if buffer has been used for write - to speedup flush.
            </summary>
        </member>
        <member name="P:NDatabase.IO.MultiBuffer.MaxPositionInBuffer">
            <summary>
              The max position in the buffer, used to optimize the flush - to flush only new data and not all the buffer
            </summary>
        </member>
        <member name="P:NDatabase.IO.MultiBuffer.Size">
            <summary>
              The buffer size.
            </summary>
        </member>
        <member name="P:NDatabase.IO.BufferPosition.Start">
            <summary>
              The current start position of the buffer
            </summary>
        </member>
        <member name="P:NDatabase.IO.BufferPosition.End">
            <summary>
              The current end position of the buffer
            </summary>
        </member>
        <member name="M:NDatabase.IO.OdbFileStream.SetPosition(System.Int64)">
            <summary>
                Sets the current position of this stream to the given value
            </summary>
            <param name="position">offset</param>
        </member>
        <member name="P:NDatabase.IO.OdbFileStream.Length">
            <summary>
                Gets the length in bytes of the stream
            </summary>
        </member>
        <member name="M:NDatabase.Tool.Wrappers.OdbString.DepthToSpaces(System.Int32)">
            <summary>
              A small method for indentation
            </summary>
            <param name="currentDepth"></param>
        </member>
        <member name="T:NDatabase.TypeResolution.CachedTypeResolver">
            <summary>
            Resolves (instantiates) a <see cref="T:System.Type"/> by it's (possibly
            assembly qualified) name, and caches the <see cref="T:System.Type"/>
            instance against the type name.
            </summary>
        </member>
        <member name="T:NDatabase.TypeResolution.ITypeResolver">
            <summary>
            Resolves a <see cref="T:System.Type"/> by name.
            </summary>
            <remarks>
            <p>
            The rationale behind the creation of this interface is to centralize
            the resolution of type names to <see cref="T:System.Type"/> instances
            beyond that offered by the plain vanilla
            <see cref="M:System.Type.GetType(System.String)"/> method call.
            </p>
            </remarks>
        </member>
        <member name="M:NDatabase.TypeResolution.ITypeResolver.Resolve(System.String)">
            <summary>
            Resolves the supplied <paramref name="typeName"/> to a
            <see cref="T:System.Type"/>
            instance.
            </summary>
            <param name="typeName">
            The (possibly partially assembly qualified) name of a
            <see cref="T:System.Type"/>.
            </param>
            <returns>
            A resolved <see cref="T:System.Type"/> instance.
            </returns>
            <exception cref="T:System.TypeLoadException">
            If the supplied <paramref name="typeName"/> could not be resolved
            to a <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="F:NDatabase.TypeResolution.CachedTypeResolver._typeCache">
            <summary>
            The cache, mapping type names (<see cref="T:System.String"/> instances) against
            <see cref="T:System.Type"/> instances.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.CachedTypeResolver.#ctor(NDatabase.TypeResolution.ITypeResolver)">
            <summary>
            Creates a new instance of the <see cref="T:NDatabase.TypeResolution.CachedTypeResolver"/> class.
            </summary>
            <param name="typeResolver">
            The <see cref="T:NDatabase.TypeResolution.ITypeResolver"/> that this instance will delegate
            actual <see cref="T:System.Type"/> resolution to if a <see cref="T:System.Type"/>
            cannot be found in this instance's <see cref="T:System.Type"/> cache.
            </param>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="typeResolver"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:NDatabase.TypeResolution.CachedTypeResolver.Resolve(System.String)">
            <summary>
            Resolves the supplied <paramref name="typeName"/> to a
            <see cref="T:System.Type"/>
            instance.
            </summary>
            <param name="typeName">
            The (possibly partially assembly qualified) name of a
            <see cref="T:System.Type"/>.
            </param>
            <returns>
            A resolved <see cref="T:System.Type"/> instance.
            </returns>
            <exception cref="T:System.TypeLoadException">
            If the supplied <paramref name="typeName"/> could not be resolved
            to a <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="T:NDatabase.TypeResolution.GenericArgumentsHolder">
            <summary>
                Holder for the generic arguments when using type parameters.
            </summary>
            <remarks>
                <p>
                    Type parameters can be applied to classes, interfaces,
                    structures, methods, delegates, etc...
                </p>
            </remarks>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericArgumentsHolder.#ctor(System.String)">
            <summary>
                Creates a new instance of the GenericArgumentsHolder class.
            </summary>
            <param name="value">
                The string value to parse looking for a generic definition
                and retrieving its generic arguments.
            </param>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericArgumentsHolder.GetGenericTypeName">
            <summary>
                The (unresolved) generic type name portion
                of the original value when parsing a generic type.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericArgumentsHolder.GetArrayDeclaration">
            <summary>
                Returns the array declaration portion of the definition, e.g. "[,]"
            </summary>
            <returns></returns>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericArgumentsHolder.GetGenericArguments">
            <summary>
                Returns an array of unresolved generic arguments types.
            </summary>
            <remarks>
                <p>
                    A empty string represents a type parameter that
                    did not have been substituted by a specific type.
                </p>
            </remarks>
            <returns>
                An array of strings that represents the unresolved generic
                arguments types or an empty array if not generic.
            </returns>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericArgumentsHolder.Split(System.String,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
                Tokenize the given <see cref="T:System.String"/> into a
                <see cref="T:System.String"/> array.
            </summary>
            <remarks>
                <p>
                    If <paramref name="s"/> is <see langword="null"/>, returns an empty
                    <see cref="T:System.String"/> array.
                </p>
                <p>
                    If <paramref name="delimiters"/> is <see langword="null"/> or the empty
                    <see cref="T:System.String"/>, returns a <see cref="T:System.String"/> array with one
                    element: <paramref name="s"/> itself.
                </p>
            </remarks>
            <param name="s">
                The <see cref="T:System.String"/> to tokenize.
            </param>
            <param name="delimiters">
                The delimiter characters, assembled as a <see cref="T:System.String"/>.
            </param>
            <param name="trimTokens">
                Trim the tokens via <see cref="M:System.String.Trim"/>.
            </param>
            <param name="ignoreEmptyTokens">
                Omit empty tokens from the result array.
            </param>
            <param name="quoteChars">
                Pairs of quote characters. <paramref name="delimiters"/> within a pair of quotes are ignored
            </param>
            <returns>An array of the tokens.</returns>
        </member>
        <member name="P:NDatabase.TypeResolution.GenericArgumentsHolder.ContainsGenericArguments">
            <summary>
                Is the string value contains generic arguments ?
            </summary>
            <remarks>
                <p>
                    A generic argument can be a type parameter or a type argument.
                </p>
            </remarks>
        </member>
        <member name="P:NDatabase.TypeResolution.GenericArgumentsHolder.IsGenericDefinition">
            <summary>
                Is generic arguments only contains type parameters ?
            </summary>
        </member>
        <member name="P:NDatabase.TypeResolution.GenericArgumentsHolder.IsArrayDeclaration">
            <summary>
                Is this an array type definition?
            </summary>
        </member>
        <member name="T:NDatabase.TypeResolution.GenericTypeResolver">
            <summary>
                Resolves a generic <see cref="T:System.Type"/> by name.
            </summary>
        </member>
        <member name="T:NDatabase.TypeResolution.TypeResolver">
            <summary>
            Resolves a <see cref="T:System.Type"/> by name.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeResolver.Resolve(System.String)">
            <summary>
            Resolves the supplied <paramref name="typeName"/> to a
            <see cref="T:System.Type"/> instance.
            </summary>
            <param name="typeName">
            The unresolved (possibly partially assembly qualified) name 
            of a <see cref="T:System.Type"/>.
            </param>
            <returns>
            A resolved <see cref="T:System.Type"/> instance.
            </returns>
            <exception cref="T:System.TypeLoadException">
            If the supplied <paramref name="typeName"/> could not be resolved
            to a <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeResolver.BuildTypeLoadException(System.String)">
            <summary>
            Creates a new <see cref="T:System.TypeLoadException"/> instance 
            from the given <paramref name="typeName"/>
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeResolver.BuildTypeLoadException(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:System.TypeLoadException"/> instance
            from the given <paramref name="typeName"/> with the given inner <see cref="T:System.Exception"/> 
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.GenericTypeResolver.Resolve(System.String)">
            <summary>
                Resolves the supplied generic <paramref name="typeName"/> to a
                <see cref="T:System.Type"/> instance.
            </summary>
            <param name="typeName">
                The unresolved (possibly generic) name of a <see cref="T:System.Type"/>.
            </param>
            <returns>
                A resolved <see cref="T:System.Type"/> instance.
            </returns>
            <exception cref="T:System.TypeLoadException">
                If the supplied <paramref name="typeName"/> could not be resolved
                to a <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="T:NDatabase.TypeResolution.TypeAssemblyHolder">
            <summary>
            Holds data about a <see cref="T:System.Type"/> and it's
            attendant <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeAssemblyHolder.TypeAssemblySeparator">
            <summary>
            The string that separates a <see cref="T:System.Type"/> name
            from the name of it's attendant <see cref="T:System.Reflection.Assembly"/>
            in an assembly qualified type name.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeAssemblyHolder.#ctor(System.String)">
            <summary>
            Creates a new instance of the TypeAssemblyHolder class.
            </summary>
            <param name="unresolvedTypeName">
            The unresolved name of a <see cref="T:System.Type"/>.
            </param>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeAssemblyHolder.GetTypeName">
            <summary>
            The (unresolved) type name portion of the original type name.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeAssemblyHolder.GetAssemblyName">
            <summary>
            The (unresolved, possibly partial) name of the attendant assembly.
            </summary>
        </member>
        <member name="P:NDatabase.TypeResolution.TypeAssemblyHolder.IsAssemblyQualified">
            <summary>
            Is the type name being resolved assembly qualified?
            </summary>
        </member>
        <member name="T:NDatabase.TypeResolution.TypeRegistry">
            <summary> 
            Provides access to a central registry of aliased <see cref="T:System.Type"/>s.
            </summary>
            <remarks>
            <p>
            Simplifies configuration by allowing aliases to be used instead of
            fully qualified type names.
            </p>
            <p>
            Comes 'pre-loaded' with a number of convenience alias' for the more
            common types; an example would be the '<c>int</c>' (or '<c>Integer</c>'
            for Visual Basic.NET developers) alias for the <see cref="T:System.Int32"/>
            type.
            </p>
            </remarks>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int32Alias">
            <summary>
            The alias around the 'int' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int32ArrayAlias">
            <summary>
            The alias around the 'int[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DecimalAlias">
            <summary>
            The alias around the 'decimal' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DecimalArrayAlias">
            <summary>
            The alias around the 'decimal[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.CharAlias">
            <summary>
            The alias around the 'char' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.CharArrayAlias">
            <summary>
            The alias around the 'char[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int64Alias">
            <summary>
            The alias around the 'long' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int64ArrayAlias">
            <summary>
            The alias around the 'long[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int16Alias">
            <summary>
            The alias around the 'short' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.Int16ArrayAlias">
            <summary>
            The alias around the 'short[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt32Alias">
            <summary>
            The alias around the 'unsigned int' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt64Alias">
            <summary>
            The alias around the 'unsigned long' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt64ArrayAlias">
            <summary>
            The alias around the 'ulong[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt32ArrayAlias">
            <summary>
            The alias around the 'uint[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt16Alias">
            <summary>
            The alias around the 'unsigned short' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.UInt16ArrayAlias">
            <summary>
            The alias around the 'ushort[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DoubleAlias">
            <summary>
            The alias around the 'double' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DoubleArrayAlias">
            <summary>
            The alias around the 'double[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.FloatAlias">
            <summary>
            The alias around the 'float' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.SingleAlias">
            <summary>
            The alias around the 'Single' type (Visual Basic.NET style).
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.FloatArrayAlias">
            <summary>
            The alias around the 'float[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DateTimeAlias">
            <summary>
            The alias around the 'DateTime' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DateAlias">
            <summary>
            The alias around the 'DateTime' type (C# style).
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DateTimeArrayAlias">
            <summary>
            The alias around the 'DateTime[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.DateTimeArrayAliasCSharp">
            <summary>
            The alias around the 'DateTime[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.BoolAlias">
            <summary>
            The alias around the 'bool' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.BoolArrayAlias">
            <summary>
            The alias around the 'bool[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.StringAlias">
            <summary>
            The alias around the 'string' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.StringArrayAlias">
            <summary>
            The alias around the 'string[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.ObjectAlias">
            <summary>
            The alias around the 'object' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.ObjectArrayAlias">
            <summary>
            The alias around the 'object[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt32Alias">
            <summary>
            The alias around the 'int?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt32ArrayAlias">
            <summary>
            The alias around the 'int?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableDecimalAlias">
            <summary>
            The alias around the 'decimal?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableDecimalArrayAlias">
            <summary>
            The alias around the 'decimal?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableCharAlias">
            <summary>
            The alias around the 'char?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableCharArrayAlias">
            <summary>
            The alias around the 'char?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt64Alias">
            <summary>
            The alias around the 'long?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt64ArrayAlias">
            <summary>
            The alias around the 'long?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt16Alias">
            <summary>
            The alias around the 'short?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableInt16ArrayAlias">
            <summary>
            The alias around the 'short?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt32Alias">
            <summary>
            The alias around the 'unsigned int?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt64Alias">
            <summary>
            The alias around the 'unsigned long?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt64ArrayAlias">
            <summary>
            The alias around the 'ulong?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt32ArrayAlias">
            <summary>
            The alias around the 'uint?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt16Alias">
            <summary>
            The alias around the 'unsigned short?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableUInt16ArrayAlias">
            <summary>
            The alias around the 'ushort?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableDoubleAlias">
            <summary>
            The alias around the 'double?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableDoubleArrayAlias">
            <summary>
            The alias around the 'double?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableFloatAlias">
            <summary>
            The alias around the 'float?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableFloatArrayAlias">
            <summary>
            The alias around the 'float?[]' array type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableBoolAlias">
            <summary>
            The alias around the 'bool?' type.
            </summary>
        </member>
        <member name="F:NDatabase.TypeResolution.TypeRegistry.NullableBoolArrayAlias">
            <summary>
            The alias around the 'bool?[]' array type.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeRegistry.#cctor">
            <summary>
            Registers standard and user-configured type aliases.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeRegistry.ResolveType(System.String)">
            <summary> 
            Resolves the supplied <paramref name="alias"/> to a <see cref="T:System.Type"/>. 
            </summary> 
            <param name="alias">
            The alias to resolve.
            </param>
            <returns>
            The <see cref="T:System.Type"/> the supplied <paramref name="alias"/> was
            associated with, or <see lang="null"/> if no <see cref="T:System.Type"/> 
            was previously registered for the supplied <paramref name="alias"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If the supplied <paramref name="alias"/> is <see langword="null"/> or
            contains only whitespace character(s).
            </exception>
        </member>
        <member name="T:NDatabase.TypeResolution.TypeResolutionUtils">
            <summary>
            Helper methods with regard to type resolution.
            </summary>
        </member>
        <member name="M:NDatabase.TypeResolution.TypeResolutionUtils.ResolveType(System.String)">
            <summary>
            Resolves the supplied type name into a <see cref="T:System.Type"/>
            instance.
            </summary>
            <param name="typeName">
            The (possibly partially assembly qualified) name of a
            <see cref="T:System.Type"/>.
            </param>
            <returns>
            A resolved <see cref="T:System.Type"/> instance.
            </returns>
            <exception cref="T:System.TypeLoadException">
            If the type cannot be resolved.
            </exception>
        </member>
    </members>
</doc>
